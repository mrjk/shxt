{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SHell eXTender","text":"<p>Easily reuse code chunks across shell scripts.</p>"},{"location":"#install","title":"Install","text":"<p>If you arrived by chance on this page, this is because an app requires shxt.sh to be installed. To fix this problem, simply run:</p> <pre><code># Install as system level\ncurl -v https://mrjk.github.io/shxt/shxt.sh | sudo bash -s install\n\n# Install for current user\ncurl -v https://mrjk.github.io/shxt/shxt.sh | bash -s install\n</code></pre> <p>Then run again you're app, it should work.</p> <p>However, if you're here to use shxt.sh in your script or as shell manager, you're at the good place, please read on!</p>"},{"location":"#using-shxt-in-your-scripts","title":"Using shxt in your scripts","text":"<p>shxt.sh virtually let you use and reuse common piece of code, usually available on internet. Shxt.sh takes advantage of this to provide a very minimalist but yet powerful tool to act as a simple dependency resolver for bash.</p> <p>Thus a very basic and common way to use shxt.sh is to always start your scripts like this:</p> <pre><code>#!/bin/bash\n\n# Auto install shxt\n. shxt.sh || eval \"$(curl -v https://mrjk.github.io/shxt/shxt.sh)\"\n</code></pre>"},{"location":"#using-shxt-with-your-daily-shell","title":"Using shxt with your daily shell","text":"<p>You may want to live try shxt in your shell, thus try this: <pre><code>. shxt.sh || eval \"SHXT_NOINSTALL=true; $(curl -v https://mrjk.github.io/shxt/shxt.sh)\"\n</code></pre></p>"},{"location":"#using-shxt-with-in-your-bashrc","title":"Using shxt with in your bashrc","text":"<p>Store your public configs online, and access them if not available. <pre><code># .bashrc\n# File bashrc managed by shxt.sh\n\n# Run or auto-install shxt.sh\n. shxt.sh || eval \"$(curl -v https://mrjk.github.io/shxt/shxt.sh); shxt_init\"\n\n# My shell config as lib\nloader use lib bash_config https://raw.githubusercontent.com/USER/dotfiles/ref/head/master/.config/bash_config.sh\n</code></pre></p>"},{"location":"advanced/","title":"Advanced","text":"<p>We cover here some advanced topics.</p>"},{"location":"advanced/#rationale","title":"Rationale","text":""},{"location":"advanced/#why-this-strange-release-process","title":"Why this strange release process","text":"<p>Because this is actually possible.</p>"},{"location":"advanced/#single-source-file","title":"Single source file","text":"<p>This make life easier: * simple to maintain * try to keep code simple and minimal * reduced dowload times because smaller files * super simple but unlock unlimited possibilities</p>"},{"location":"advanced/#bash-and-not-posix","title":"Bash and not POSIX","text":"<p>Maybe later. Eventually. Why not ?</p>"},{"location":"advanced/#bash-and-not-other","title":"Bash and not other","text":"<p>Please reimplement it yourself for your favorite shell :-) I'll post a link here.</p>"},{"location":"advanced/#technical-points","title":"Technical points","text":""},{"location":"advanced/#first-writable-path-directory-for-auo-install","title":"First writable $PATH directory for auo-install","text":"<p>shxt.sh is configured to auto-install itself, to simply cache itself. While this behavior can be</p>"},{"location":"advanced/#data-storage-and-cache","title":"Data storage and cache","text":"<p>When used in live terminal instance, data is always stored in home directory, since sxht.sh need to cache files.</p> <p>It will try many different paths until it find one. But it is possible to change this behavior with a command flag or environment variable.</p> <p>To implement.</p>"},{"location":"advanced/#development","title":"Development","text":"<p>We use strict bash by default, follow the bash linter rules.</p>"},{"location":"advanced/#project-layout","title":"Project layout","text":"<pre><code>shxt.sh           # Shxt.sh single file source code\ndocs/             # Provide documentation and release\n    mkdocs.yml    # The configuration file.\n    index.md      # The documentation homepage.\n    ...           # Other markdown pages, images and other files.\n</code></pre>"},{"location":"install/","title":"Install","text":"<p>install code</p> <pre><code>curl -v https://mrjk.github.io/shxt/shxt.sh | bash -s install\n</code></pre>"},{"location":"install/#debian","title":"Debian","text":"<pre><code>apt update; apt install -y bash curl\ncurl -v https://mrjk.github.io/shxt/shxt.sh | bash -s install\n</code></pre>"},{"location":"source/","title":"Source","text":"<p>This is the full code of shxt.sh. You can also fetch it with curl on https://mrjk.github.io/shxt/shxt.sh.</p> <pre><code>#!/bin/bash\n\n\n# =============================================================\n# Documentation\n# =============================================================\n\n# Usage API:\n# source import.sh ../lib\n# import https://raw.githubusercontent.com/qzb/is.sh/master/is.sh\n# import myapp_lib1.sh\n# import myapp_lib2.sh\n\n# package.sh file is.sh@v1.1.2 \n\n# See: https://github.com/dylanaraps/pure-bash-bible/blob/master/README.md#get-the-terminal-size-in-lines-and-columns-from-a-script\n\n# a vars from untouched shell: \n# bash: ( env -i bash --norc -o posix -c set ) | less\n# sh: ( env -i sh --norc -c -- set )\n\n\n# =============================================================\n# Libraries\n# =============================================================\n\n# Portable realpath implementation in shell script\n# Usage:\n#  realpath [&lt;PATH&gt;]\n# Example:\n#  realpath \"${BASH_SOURCE[0]}\"\n#  realpath ../bin/file\n#  realpath\n# Source: https://stackoverflow.com/a/45828988\nrealpath()\n( \n  # TOFIX: Verify this function still work in strict mode\n  # set -o errexit -o nounset\n  declare link=\"${1:-$PWD}\"\n\n  # Try with real realpath first\n  if command realpath \"$link\" 2&gt;/dev/null; then return; fi\n\n  # If it's a directory, just skip all this.\n  if cd \"$link\" 2&gt;/dev/null; then\n    pwd -P \"$link\"; return 0\n  fi\n\n  # Resolve until we are out of links (or recurse too deep).\n  declare n=0 limit=1024\n  while [[ -L $link ]] &amp;&amp; [[ $n -lt $limit ]]; do \n    n=$((n + 1))\n    cd \"$(dirname -- ${link})\" \\\n      &amp;&amp; link=\"$(readlink -- \"${link##*/}\")\"\n  done; cd \"${link%/*}\"\n\n  # Check limit recursion\n  [[ $n -lt $limit ]] || {\n    &gt;&amp;2 printf \"ERROR: Recursion limit ($limit) exceeded.\\n\"\n    return 2; }\n\n  printf '%s/%s\\n' \"$(pwd -P)\" \"${link##*/}\"\n)\n\n\n# Add a &lt;PATH&gt; to &lt;PATHS_VAR&gt;\n# Usage:\n#  varpath_prepend &lt;PATHS_VAR&gt; &lt;PATH&gt;\n# Example:\n#  varpath_prepend PATH $PWD/app/bin\nvarpath_append_force() {\n  local var=$1\n  local path=$2\n\n  log TRACE \"Prepend to $var: $path\"\n  if [[ \":${!var}:\" != *\":$path:\"* ]]; then\n  # if [ -d \"$path\" ] &amp;&amp; [[ \":${!var}:\" != *\":$path:\"* ]]; then\n  #   log TRACE \"Add prepend to '$var': $path\"\n    export \"${var}=${!var:+\"${!var}:\"}$path\"\n\n  fi\n}\nvarpath_append() {\n  local var=$1\n  local path=$2\n\n  if [ -d \"$path\" ]; then\n    varpath_append_force \"$var\" \"$path\"\n  else\n    log TRACE \"Skip directory for $var: $path\"\n  fi\n\n}\n\n\n# Add a &lt;PATH&gt; to &lt;PATHS_VAR&gt;\n# Usage:\n#  varpath_append &lt;PATHS_VAR&gt; &lt;PATH&gt;\n# Example:\n#  varpath_append PATH $PWD/app/bin\nvarpath_prepend_force() {\n  local var=$1\n  local path=$2\n\n  if [[ \":${!var}:\" != *\":$path:\"* ]]; then\n    log TRACE \"Append to $var: $path\"\n    export \"${var}=$path${!var:+\":${!var}\"}\"\n  else\n    log TRACE \"Already in path $var: $path\"\n    return 1\n  fi\n}\nvarpath_prepend() {\n  local var=$1\n  local path=$2\n\n  if [ -d \"$path\" ]; then\n    varpath_prepend_force \"$var\" \"$path\"\n  else\n    log TRACE \"Skip directory for $var: $path\"\n  fi\n\n}\n\n\n# Find first matching file called &lt;NAME&gt; in list of &lt;PATHS_VAR&gt;\n# Usage:\n#  varpath_find &lt;PATHS_VAR&gt; &lt;NAME&gt;\nvarpath_find ()\n{\n  local var_name=$1\n  local target=$2\n  local path=\n  log TRACE \"File lookup: '$target' from \\$${var_name}\"\n\n  local paths=$(/usr/bin/tr ':' '\\n' &lt;&lt;&lt; \"${!var_name}\")\n  while read path ; do\n    file=\"$path/$target\"\n    if [[ -f \"$file\" ]]; then\n      log TRACE \"File lookup successed: $file\"\n      printf \"%s\\n\" \"$file\"\n      return 0\n    else\n      log TRACE \"File lookup failed: $file\"\n    fi\n  done &lt;&lt;&lt;\"$paths\"\n  log TRACE \"Could not find file '$target' in '\\$${var_name}'\"\n  # &gt;&amp;2 printf \"%s\\n\" \"WARN: Could not find file '$target' in \"${var_name}\"\"\n  return 1\n}\n\nvarpath_find2 ()\n{\n  local var_name=$1\n  local target=$2\n  local path=\n  log TRACE \"File lookup: '$target' from \\$${var_name}\"\n\n  local paths=$(/usr/bin/tr ':' '\\n' &lt;&lt;&lt; \"${!var_name}\")\n  while read path ; do\n    file=\"$path/$target\"\n    if [[ -f \"$file\" ]]; then\n      log TRACE \"File lookup successed: $file\"\n      printf \"%s\\n\" \"$file\"\n      return 0\n    else\n      log TRACE \"File lookup failed: $file\"\n    fi\n  done &lt;&lt;&lt;\"$paths\"\n  log TRACE \"Could not find file '$target' in '\\$${var_name}'\"\n  # &gt;&amp;2 printf \"%s\\n\" \"WARN: Could not find file '$target' in \"${var_name}\"\"\n  return 1\n}\n\n\n# Find all writable or parents dirs and return a colon separated string result\n# Usage:\n#  varpath_find_rw_dir [&lt;PATHS&gt;...]\nvarpath_find_rw_dir ()\n{\n  local target=($@)\n  if [[ \"$@\" == '-' ]] ; then\n    # Read from stdin\n    local target=() line=\n    # exec &lt; &lt;(printf '%s\\n' \"$@\")\n    while IFS= read -r line; do\n      [ -z \"$line\" ] || target+=($line)\n    done &lt;&lt;&lt;\"$(cat /dev/stdin)\"\n  fi\n  local i=0\n  local result=''\n  while (( i &lt; ${#target[@]} )); do\n      local path=\"${target[i]}\"\n      local parent=${path%/*}\n      if [ -d \"$path\" ]; then\n        if [ -w \"$path\" ]; then\n          result=\"${result:+$result:}$path\"\n        fi\n      elif [ -d \"$parent\" ]; then\n        if [ -w \"$parent\" ]; then\n          result=\"${result:+$result:}$path\"\n        fi\n      fi\n      ((i++))\n  done\n  printf \"%s\" \"$result\"\n}\n\n# Test if shell is executed or sourced\n# # if [[ \"${BASH_SOURCE[0]}\" =~ .*\"$0\"$ ]]; then\n# if [[ \"${BASH_SOURCE[0]}\" == \"$0\" ]]; then\n#     echo EXECUTED\n# else\n#     echo SOURCED\n# fi\n\n# Return true if context is executed\nshell_is_executed () {\n  [[ \"${BASH_SOURCE[0]}\" == \"$0\" ]]\n}\n\n# Return false if context is sourced\nshell_is_sourced () {\n  ! shell_is_executed\n}\n\n# Return false if context is sourced\nshell_is_known () {\n  local name=$1\n  case \"$name\" in\n    */sh) echo \"$name\" ;; \n    */ash) echo \"$name\" ;; \n    */bash) echo \"$name\" ;; \n    */zsh) echo \"$name\" ;; \n    *) return 1;; \n  esac\n}\n\n# Sources:\n# https://serverfault.com/questions/146745/how-can-i-check-in-bash-if-a-shell-is-running-in-interactive-mode\n\n# Return true if terminal stdin is interactive terminal\nshell_is_interactive () {\n  [ -t 0 ]\n}\n\n# Return true if terminal stdin is not interactive\nshell_is_not_interactive () {\n  ! [ -t 0 ]\n}\n\n\n\n# Source a shell file\nshell_source ()\n{\n  local path=$1\n  shift 1 || true\n  local rc=0\n\n  PWD=\"${path%/*}\" . \"$path\" $@ || \\\n    {\n      rc=$?\n      &gt;&amp;2 printf \"Failed to load lib returned $rc: %s\\n\" \"$p\"\n    }\n  return $rc\n}\n\n\n# Download an &lt;URL&gt; into &lt;PATH&gt; or stdout\n# Usage:\n#  download_file &lt;URL&gt;\n#  download_file &lt;URL&gt; &lt;PATH&gt;\ndownload_file() {\n  local url=$1\n  local filename=${2:--}\n\n  if [ -z \"$url\" ]; then\n      echo \"Usage: download_file &lt;URL&gt; [&lt;FILENAME&gt;]\"\n      return 1\n  fi\n\n  # Create destination dir\n  if [ \"$filename\" != '-' ]; then\n    local parent=\"${filename%/*}\"\n    [[ -d \"${parent}\" ]] || mkdir -p \"${parent}\"\n  fi\n\n  # Find download tool\n  local rc=0\n  if command -v curl &gt; /dev/null; then\n      curl -L -s -o \"$filename\" \"$url\" || rc=$?\n      if [[ $rc -ne 0 ]]; then\n        log WARN \"Failure after curl: $rc\"\n        return 1\n      fi\n  elif command -v wget &gt; /dev/null; then\n      wget -O \"$filename\" \"$url\"\n  else\n      printf \"%s\\n\" \"Neither curl nor wget is installed. Please install one of them to use this function.\"\n      return 1\n  fi\n\n  # Report\n  if [ $? -ne 0 ]; then\n    &gt;&amp;2 printf \"ERROR: Failed to download the file: %s\\n\" \"$url\"\n    return 1\n  else\n    log TRACE \"File downloaded successfully as: $filename\"\n  fi\n}\n\n\n\n\n\n\n\n# SHXT_LOG_LEVEL=${SHXT_LOG_LEVEL:-INFO}  # DRY, DEBUG, TRACE\n# SHXT_LOG_SCALE=\"TRACE:DEBUG:RUN:INFO:DRY:HINT:NOTICE:CMD:USER:WARN:ERR:ERROR:CRIT:TODO:DIE:QUIT:PROMPT\"\n\n\n# CLI libraries\n# =================\n# Validate log level pass aginst limit\n_log_validate_level ()\n{\n  local SHXT_LOG_SCALE=\"${SHXT_LOG_SCALE:-TRACE:DEBUG:INFO:NOTICE:WARN:ERR:ERROR:CRIT:TODO:DIE:QUIT:PROMPT}\"\n\n  local level=$1\n  local limit_level=${2:-${SHXT_LOG_SCALE%%:*}}\n\n  if [[ ! \":${SHXT_LOG_SCALE#*$limit_level:}:$limit_level:\" =~ :\"$level\": ]]; then\n    if [[ ! \":${SHXT_LOG_SCALE}\" =~ :\"$level\": ]]; then\n      &gt;&amp;2 printf \"%s\\n\" \"  BUG: Unknown log level: $level\"\n    fi\n    return 1\n  fi\n}\n\n# Logging support, with levels\nlog () \n{\n  local SHXT_LOG_LEVEL=${SHXT_LOG_LEVEL:-INFO}\n\n  local old_setting=${-//[^x]/}; set +x\n  local level=\"${1:-DEBUG}\"\n  shift 1 || true\n\n  # Check log level filter\n  if _log_validate_level \"$level\" \"$SHXT_LOG_LEVEL\"; then\n\n    local msg=${*}\n    if [[ \"$msg\" == '-' ]]; then\n      msg=\"$(cat -)\"\n    fi\n    while read -r -u 3 line; do\n      &gt;&amp;2 printf \"%6s: %s\\\\n\" \"$level\" \"${line:- }\"\n    done 3&lt;&lt;&lt;\"$msg\"\n  fi\n\n  # Restore trace mode if was enabled\n  if [[ -n \"${old_setting-}\" ]]; then set -x; else set +x; fi\n}\n\n# Terminate all with error message and rc code\nlog_die ()\n{\n    local rc=${1:-1}\n    shift 1 || true\n    local msg=\"${*:-}\"\n    local prefix=DIE\n    [[ \"$rc\" -eq 0 ]] || prefix=DIE\n    if [[ -z \"$msg\" ]]; then\n      [ \"$rc\" -ne 0 ] || exit 0\n      log \"$prefix\" \"Program terminated with error: $rc\"\n    else\n      log \"$prefix\" \"$msg\"\n    fi\n\n    # Remove EXIT trap and exit nicely\n    trap '' EXIT\n    exit \"$rc\"\n}\n\n\n\n\n\n\n\n# =============================================================\n# Internal libraries: Registries\n# =============================================================\n\n\n# Register library\n# Usage: loader_register STORE PATH [NAME]\nloader_register()\n{\n  local store_name=$1\n  local store=${!store_name}\n  local path=$2\n  local file=${3:-${path##*/}}\n  local dir=${path%/*}\n\n  # # Do initial load\n  # if [[ -z \"${SHLIB-}\" ]]; then\n  #   SHSRC=$path\n  #   SHSRC_FILE=$file\n  #   SHSRC_DIR=$dir\n  # fi\n\n  # Check if lib is not already registered\n  # [[ \":${store-}:\" != *:$file:* ]] || {\n  [[ \":${store-}:\" != *:$file=*:* ]] || {\n    &gt;&amp;2 printf \"Item already registered: %s\\n\" \"$file\"\n    return 1\n  }\n\n  # Add module into SHLIB\n  declare -g \"$store_name\"=\"${store:+$store:}$file=$path\"\n\n  # Importing vars\n  _IMPORT_PATH=$path\n  _IMPORT_FILE=$file\n  _IMPORT_DIR=$dir\n}\n\n\n\n\n\n\n# =============================================================\n# Init Loader\n# =============================================================\n\n\n# Prepare import.sh environment\nshxt_init()\n{\n\n  local auto_install=true\n  local auto_update=true\n  local debug=false\n  local trace=false\n  local OPTIND=0\n  while getopts 'dxuUlL' opt; do\n    case ${opt} in\n      d)\n        debug=true\n        ;;\n      x)\n        trace=true\n        ;;\n      u)\n        auto_update=true\n        ;;\n      U)\n        auto_update=false\n        ;;\n      l)\n        auto_install=true\n        ;;\n      L)\n        auto_install=false\n        ;;\n      ?)\n        log ERROR \"Invalid option: -${OPTARG}.\"\n        return 1\n        ;;\n    esac\n    OPTIND=$((OPTIND + 1))\n  done\n  OPTIND=$((OPTIND - 1))\n  shift \"$OPTIND\"\n\n\n  # Enable flags\n  if [[ \"$debug\" == true ]]; then\n    SHXT_LOG_LEVEL=TRACE\n    log INFO \"shxt.sh debug mode enabled\"\n  fi\n  if [[ \"$trace\" == true ]]; then\n    set -x\n  fi\n\n  # Init core\n  local d=${1-} # ${1:-$(ps -o args= $$)}\n\n  local path=$(realpath \"$0\")\n  local root=\"${path%/*}${d:+/$d}\"\n\n\n  # Autodetect current installation\n\n  local install_path=$(command -v \"shxt.sh\" 2&gt;/dev/null)\n  local need_update=false\n  if [[ \"$auto_install\" == true ]] &amp;&amp; [[ ! -x \"$install_path\" ]] ; then\n    # Auto install in PATH if not installed\n    log INFO \"Auto-installing shxt.sh\"\n    if _loader2__install; then\n      need_update=true\n    fi\n\n  elif [[ \"$auto_update\" == true ]] &amp;&amp; [[ -x \"$install_path\" ]] ; then\n    # Run auto update ...\n    local max_days=7\n    local max_age_ts=$(date -d \"now - $max_days days\" +%s)\n    local last_update_ts=$(date -r \"$install_path\" +%s)\n    if (( last_update_ts &lt;= max_age_ts )); then\n      # echo \"$filename is older than 100 days\"\n      log INFO \"Auto-updating shxt.sh because older than $max_days days\"\n      if _loader2__install; then\n        need_update=true\n      fi\n    else\n      log TRACE \"No need to update, newer than $max_days days\"\n    fi\n  fi\n\n  # Reload code\n  if [[ \"$need_update\" == true ]]; then\n    log TRACE \"Reloading shxt source code\"\n    install_path=$(command -v \"shxt.sh\" 2&gt;/dev/null)\n    . \"$install_path\"\n  fi\n  export SHXT_INSTALL_PATH=$install_path\n\n\n\n  # set +x\n\n  # Auto-register into SHLIB or quit\n  export SHXT_LIBS=''\n  loader_register SHXT_LIBS \"$path\" shxt.sh || return 0\n  export SHXT_VERSION=0.0.1\n  export USER=${USER:-$(id -u)}\n  export SHXT_NEEDLE=${SHXT_NEEDLE:-${USER}-$(cksum &lt;&lt;&lt; \"$path\" | cut -f 1 -d ' ')}\n\n  # Find most suitable RW path\n  export SHXT_DATA_DIRS=$(varpath_find_rw_dir \\\n    \"$HOME/.local/share/shxt\" \\\n    \"$HOME/.tmp/shxt\" \\\n    \"/tmp/\" \\\n    \"/dev/shm/\" \\\n    \"$root/cache/\" \\\n    \"$root/tmp/\"\n    )\n\n  # Keep only first writable dir and append program needle\n  export SHXT_RW_PATH=\"${SHXT_DATA_DIRS%%:*}${SHXT_DATA_DIRS:+/$SHXT_NEEDLE}\"\n\n  # Etra dirs\n  export SHXT_DIR_BIN=${SHXT_RW_PATH:+$SHXT_RW_PATH/bin}\n  export SHXT_DIR_LIB=${SHXT_RW_PATH:+$SHXT_RW_PATH/lib}\n  export SHXT_DIR_FILES=${SHXT_RW_PATH:+$SHXT_RW_PATH/files}\n\n  [ -d \"${SHXT_DIR_BIN:-}\" ] || mkdir -p \"${SHXT_DIR_BIN}\"\n  [ -d \"${SHXT_DIR_LIB:-}\" ] || mkdir -p \"${SHXT_DIR_LIB}\"\n  [ -d \"${SHXT_DIR_FILES:-}\" ] || mkdir -p \"${SHXT_DIR_FILES}\"\n\n\n  # return 1\n\n  # # Prepare lookup paths\n\n  export SHXT_LIB_PATHS=\n  # varpath_append SHXT_LIB_PATHS \"$root/lib\"\n  # varpath_append SHXT_LIB_PATHS \"$root/libexec\"\n  # varpath_append SHXT_LIB_PATHS \"$root\"\n  # varpath_append SHXT_LIB_PATHS \"$SHXT_DIR_SHARED/lib\"\n  # varpath_append SHXT_LIB_PATHS \"$SHXT_DIR_DOWNLOADS/$SHXT_NEEDLE/lib\"\n\n  # export SHXT_FILE_PATHS=\n  # varpath_append SHXT_FILE_PATHS \"$root/share\"\n  # varpath_append SHXT_FILE_PATHS \"$root\"\n  # varpath_append SHXT_FILE_PATHS \"$SHXT_DIR_SHARED/share\"\n  # varpath_append SHXT_FILE_PATHS \"$SHXT_DIR_DOWNLOADS/$SHXT_NEEDLE/files\"\n\n  export SHXT_BIN_PATHS=$PATH\n  # varpath_prepend SHXT_BIN_PATHS \"/usr/local/sbin/\"\n  # varpath_prepend SHXT_BIN_PATHS \"/usr/local/bin/\"\n  # varpath_prepend SHXT_BIN_PATHS \"$HOME/bin\"\n  # varpath_prepend_force SHXT_BIN_PATHS \"$HOME/.local/bin\"\n  # varpath_prepend_force SHXT_BIN_PATHS \"$HOME/.local/scripts\"\n\n  varpath_prepend SHXT_BIN_PATHS \"$root/bin\"\n  varpath_prepend SHXT_BIN_PATHS \"$root\"\n  varpath_prepend SHXT_BIN_PATHS \"$SHXT_DIR_BIN\"\n  varpath_prepend SHXT_BIN_PATHS \"$SHXT_DIR_SHARED/bin\"\n  # varpath_prepend SHXT_BIN_PATHS \"$SHXT_DIR_DOWNLOADS/$SHXT_NEEDLE/bin\"\n\n  varpath_prepend SHXT_BIN_PATHS \"$SHXT_RW_PATH\"\n\n  # log WARN \"PATH DIRS: $SHXT_BIN_PATHS\"\n\n  # Self register and init\n  # export SHXT_BIN_PATHS_OLD=${SHXT_BIN_PATHS_OLD:-$PATH}\n  # export SHXT_FILE_MAP=\n  # export SHLIB=\n  # export SHXT_LIBS='toto:titi'\n\n  # echo \"RET=$(shell_is_known $path)\"\n  # return 1\n  # loader_register SHXT_LIBS \"$path\" \n\n  # export PATH=$SHXT_BIN_PATHS\n\n\n  log TRACE \"shxt.sh inited: $SHXT_RW_PATH\"\n\n}\n\n\n# Ensure shxt.sh is installed gloabally\n_loader2__install ()\n{\n\n  local dest=${1:-}\n  # local url=\"https://mrjk.github.io/shxt/shxt.sh\"\n  # local url=\"https://mrjk.github.io/shxt/v.1/shxt.sh\"\n  local url=\"https://raw.githubusercontent.com/mrjk/shxt/refs/heads/main/shxt.sh\"\n\n  local force=false\n  while getopts ':f' opt; do\n    case ${opt} in\n      f)\n        force=true\n        ;;\n      ?)\n        log ERROR \"Invalid option: -${OPTARG}.\"\n        return 1\n        ;;\n    esac\n  done\n\n  # Quit if already installed\n  local existing=$(command -v \"shxt.sh\" 2&gt;/dev/null)\n  if [[ -x \"$existing\" ]] ; then\n    if [[ \"$force\" != true ]]; then\n      log TRACE \"shxt.sh already installed in $existing\"\n      return 0\n    fi\n  fi\n\n  # Detect install path\n  local result=\n  if [ -n \"$dest\" ]; then\n    dest=$(varpath_find_rw_dir \"$dest\")\n  else\n\n    dest=$(tr ':' '\\n' &lt;&lt;&lt; \"$PATH\" | tac | varpath_find_rw_dir -)\n    dest=${dest%%:*}\n  fi\n\n  # Ensure destination dir exists\n  [ -d \"$dest\" ] || mkdir -p \"$dest\"\n  if [ ! -w \"$dest\" ] ; then\n    log ERROR \"Impossible to install or write in path: $dest\"\n    return 1\n  fi\n\n  # Ensure a file has been updated\n  local _shxt_ctx_target_download_path=\"$dest/shxt.sh\"\n  log INFO \"Downloading $_shxt_ctx_target_download_path from $url ...\"\n  if download_file \"$url\" \"$_shxt_ctx_target_download_path\"; then\n    chmod +x \"$_shxt_ctx_target_download_path\"\n\n    log INFO \"shxt.sh installed in $dest\"\n  else\n    log ERROR \"Failed to install shxt.sh\"\n    return 1\n  fi\n}\n\n\n\n_loader2__init ()\n{\n  echo \"Init or reconfigure shxt $@\"\n}\n\n_loader2__clean ()\n{\n  echo \"Clean shxt $@\"\n}\n\n\n\n# =============================================================\n# NEW API V2 helpers\n# =============================================================\n\n_loader2__ctx_clean () {\n  unset ${!_shxt_ctx_*}\n}\n\n_loader2__ctx_init () {\n\n  export _shxt_ctx_kind=$1\n  export _shxt_ctx_target=$2\n  export _shxt_ctx_target_installed=false\n  export _shxt_ctx_target_downloaded=false\n\n  export _shxt_ctx_store_name=\n  export _shxt_ctx_store_paths=\n\n  export _shxt_ctx_target_download_dir=\n  export _shxt_ctx_target_download_path=\n  export _shxt_ctx_target_dir=\n  export _shxt_ctx_target_path=\n\n  # source_url=${3:-}\n\n  case \"$_shxt_ctx_kind\" in\n    bin)\n      _shxt_ctx_store_name=SHXT_BIN_PATHS\n      _shxt_ctx_target_download_dir=${SHXT_RW_PATH:+$SHXT_RW_PATH/bin}\n      # path_suffix=\"$SHXT_DIR_BIN\"\n      ;;\n    lib)\n      _shxt_ctx_store_name=SHXT_LIB_PATHS\n      _shxt_ctx_target_download_dir=${SHXT_RW_PATH:+$SHXT_RW_PATH/lib}\n      # path_suffix=\"$SHXT_DIR_LIB\"\n      ;;\n    file)\n      _shxt_ctx_store_name=SHXT_FILE_PATHS\n      _shxt_ctx_target_download_dir=${SHXT_RW_PATH:+$SHXT_RW_PATH/files}\n      # path_suffix=\"$SHXT_DIR_FILES\" \n      ;;  \n    *) \n      &gt;&amp;2 printf \"_loader2__ctx_init does not support kind '%s', please use one of: %s\\n\" \"$_shxt_ctx_kind\" \"bin, lib or file\"\n      return 8\n    ;;\n  esac\n\n  # Ensure path is always up to date\n  export PATH=$SHXT_BIN_PATHS\n\n  # Set custom paths\n  _shxt_ctx_store_paths=${!_shxt_ctx_store_name}\n  _shxt_ctx_target_download_path=${_shxt_ctx_target_download_dir:+$_shxt_ctx_target_download_dir/$_shxt_ctx_target}\n\n  # Lookup if not downloaded\n  if [ -f \"$_shxt_ctx_target_download_path\" ]; then\n    _shxt_ctx_target_path=\"$_shxt_ctx_target_download_path\"\n    _shxt_ctx_target_downloaded=true\n  else\n    _shxt_ctx_target_path=$(varpath_find2 \"$_shxt_ctx_store_name\" \"$_shxt_ctx_target\" || true)\n  fi\n\n  # Report if installed\n  _shxt_ctx_target_dir=${_shxt_ctx_target_path%/*}\n  if [ -f \"$_shxt_ctx_target_path\" ]; then\n    _shxt_ctx_target_installed=true\n  fi\n\n}\n\n# ======================\n# NEW API V2 LOADER\n# ======================\n\n\n_loader2__download ()\n{\n  _loader2__ctx_init \"$@\"\n  shift 2\n  local url=${1:-}\n\n  # Ensure URL is available\n  if [ -z \"$url\" ]; then\n    log CRIT \"Missing URL for $_shxt_ctx_target !\"\n    return 1\n  fi\n\n  if [ \"$_shxt_ctx_target_downloaded\" != true ]; then\n    # log INFO \"Downloading $_shxt_ctx_target ...\"\n    _loader2__update \"$_shxt_ctx_kind\" \"$_shxt_ctx_target\" \"$url\"\n  # else\n  #   log INFO \"Using downloaded $_shxt_ctx_target ...\"\n  fi\n\n}\n\n_loader2__update ()\n{\n  _loader2__ctx_init \"$@\"\n  shift 2\n  local url=${1:-}\n\n  # Ensure URL is available\n  if [ -z \"$url\" ]; then\n    log CRIT \"Missing URL for $_shxt_ctx_target !\"\n    return 1\n  fi\n\n  # Ensure a file has been updated\n  log INFO \"Downloading $_shxt_ctx_target from $url ...\"\n  download_file \"$url\" \"$_shxt_ctx_target_download_path\"\n  if [ \"$_shxt_ctx_kind\" == bin ]; then\n    chmod +x \"$_shxt_ctx_target_download_path\"\n  fi\n}\n\n_loader2__use ()\n{\n  _loader2__ctx_init \"$@\"\n  shift 2\n  local url=${1:-}\n\n  if [ \"$_shxt_ctx_target_installed\" != true ]; then\n    _loader2__update \"$_shxt_ctx_kind\" \"$_shxt_ctx_target\" \"$url\"\n  fi\n\n  # Enable the thing ...\n  case \"$_shxt_ctx_kind\" in\n    lib)\n      local old_cd=$PWD\n      log INFO \"Sourcing lib $_shxt_ctx_target_path\"\n      cd \"${_shxt_ctx_target_dir}\"\n      . \"${_shxt_ctx_target_path}\"\n      cd \"${old_cd}\"\n      ;;\n    file) ;;  \n  esac\n\n}\n\n_loader2__path ()\n{\n  _loader2__ctx_init \"$@\"\n  printf '\\s' \"$_shxt_ctx_target_path\"\n}\n\n_loader2__cat ()\n{\n  _loader2__ctx_init \"$@\"\n  if [ -f \"$_shxt_ctx_target_path\" ]; then\n    cat \"$_shxt_ctx_target_path\"\n  fi\n  return 1\n}\n\n\n_loader2__help_cli ()\n{\n  cat &lt;&lt;EOF\nMode: Executed\nUsage: $0 --help\n  $0 version\n  $0 help\n  $0 install [PATH]         Install/update automatically in PATH\n\n\nInfos:\n  SHXT_INSTALL_PATH=$SHXT_INSTALL_PATH\nEOF\n\n}\n\n_loader2__help_api ()\n{\n  cat &lt;&lt;EOF\nMode: Sourced\nUsage: . $0\n  $0 version\n  $0 help\n  $0 install [PATH]         Install/update automatically in PATH\n\n  $0 use [bin|lib|file] [NAME] [PATH]         Use an item, locally or remotely\n  $0 download [bin|lib|file] [NAME] [PATH]    Download an item\n  $0 update [bin|lib|file] [NAME] [PATH]      Always update an item\n\nInfos:\n  SHXT_INSTALL_PATH=$SHXT_INSTALL_PATH\n\nEOF\n\n}\n\n\nloader_cli ()\n{\n  local action=${1:-help}\n  case \"$action\" in\n    help|--help|-h)\n      _loader2__help_cli\n      return $?\n    ;;\n  esac\n\n  loader \"$@\"\n\n}\n\n\n# Main API\nloader ()\n{\n  local action=$1\n  shift 1\n\n  case \"$action\" in\n    version)\n      printf '%s\\n' \"1.0.0\"\n      return $?\n    ;;\n    install)\n      _loader2__install \"$@\"\n      return $?\n    ;;\n    init|conf)\n      _loader2__init \"$@\"\n      return $?\n    ;;\n    app|start|clean)\n      _loader2__clean \"$@\"\n      return $?\n    ;;\n  esac\n\n\n  case \"$action\" in\n    # Behavioral settings\n    download|install)\n      _loader2__download \"$@\"\n    ;;\n    update)\n      _loader2__update \"$@\"\n    ;;\n    use|source|enable)\n      _loader2__use \"$@\"\n    ;;\n\n    # Informative API\n    path)\n      _loader2__path \"$@\"\n    ;;\n    cat)\n      _loader2__cat \"$@\"\n    ;;\n\n    *) \n      &gt;&amp;2 printf \"loader_use does not support action '%s', please use one of: %s\\n\" \"$action\" \"bin, lib or file\"\n      return 8\n    ;;\n  esac\n\n  _loader2__ctx_clean\n\n}\n\n\n# =============================================================\n# Internal libraries\n# =============================================================\n\n\n# # =============================================================\n# # Script loader\n# # =============================================================\n\n# # if [[ \"${BASH_SOURCE[0]}\" =~ .*\"$0\"$ ]]; then\n# if [[ \"${BASH_SOURCE[0]}\" == \"$0\" ]]; then\n\n#   &gt;&amp;2 printf \"$0 is not meant to be called, but sourced in shell scripts. See help usage below:\\n\\n\"\n#   import__help\n#   exit 1\n\n# else\n#   shxt_init \"$@\"\n# fi\n\n\n# Use cases:\n#  eval \"$(cat ../shxt.sh)\"\n\n# log WARN \"'${BASH_SOURCE[0]}' == $0\"\n\n# if [[ \"${BASH_SOURCE[0]}\" =~ .*\"$0\"$ ]]; then\n# if [[ \"${BASH_SOURCE[0]}\" == \"shxt.sh\" ]]; then\nif [[ \"shxt.sh\" == .*\"$0\"$ ]]; then\n  # started as CLI\n  shxt_init\n  loader_cli \"$@\"\n\nelif [[ \"${BASH_SOURCE[0]}\" == \"$0\" ]]; then\n  # Loaded as library for any programs\n  shxt_init\n\nelse\n  shxt_init \"$@\"\n\nfi\n</code></pre>"},{"location":"scripts/install/","title":"Installation in scripts","text":"<p>Production release for https://mrjk.github.io/shxt/shxt.sh is available here on this website.</p> <p>So to make it live-run and auto-install (require internet the first time): <pre><code>#!/bin/bash\n\n# Run or auto-install shxt.sh\n. shxt.sh || eval \"$(curl -v https://mrjk.github.io/shxt/shxt.sh); shxt_init\"\n</code></pre></p> <p>If you are sure you have already installed shxt.sh before: <pre><code>#!/bin/bash\n\n# Require shxt to be installed locally\n. shxt.sh || { echo \"Shxt.sh is missing, check https://mrjk.github.io/shxt/\"; exit 1; }\n</code></pre></p> <p>If you always want to use the latest version without installation (always require internet): <pre><code>#!/bin/bash\n\n# Always require internet connexion to run\neval \"$(curl -v https://mrjk.github.io/shxt/shxt.sh); shxt_init\"\n</code></pre></p>"},{"location":"scripts/usage/","title":"Usage","text":"<p>Once shxt.sh is available, you can use it's API. The API is quite simple and minimalist. Thus, it offers a simple API following the syntax:</p> <pre><code>loader ACTION KIND NAME [URL]\n</code></pre> <p>Where action is mostly <code>use</code>, kind one of bin, lib or files. And then you set a name and a source URL as fallback.</p>"},{"location":"scripts/usage/#basic-usage","title":"Basic usage","text":"<p>Thus, to use yadm in your project, you can either distribute the source code of yadm in your project, either you can fetch it from remote URL:</p> <pre><code># Ensure yadm file in bin/yadm is executable\nloader use bin yadm\n\n# Same as above, but auto-install yadm if not distributed\nloader use bin yadm https://raw.githubusercontent.com/yadm-dev/yadm/refs/heads/master/yadm\n</code></pre> <p>Then you can access to yadm directly: <pre><code>yadm help\ncommand -v yadm\necho $PATH\n</code></pre></p> <p>So to use various tools in your script, you can use: <pre><code>loader use bin hr https://raw.githubusercontent.com/LuRsT/hr/refs/heads/master/hr\nloader use bin esh https://raw.githubusercontent.com/jirutka/esh/refs/heads/master/esh\nloader use bin has https://raw.githubusercontent.com/kdabir/has/refs/heads/master/has\nloader download bin spark https://raw.githubusercontent.com/holman/spark/refs/heads/master/spark\n</code></pre></p> <p>It is possible to use any references, like a branch or specific tag.</p> <p>Note: When you select a project on github, don't forget to use url starting by https://raw.githubusercontent.com.</p> <p>It also works for binaries, directly via the public github release API: <pre><code>loader use bin mise https://github.com/jdx/mise/releases/download/v2024.1.0/mise-v2024.1.0-linux-x64\n\nloader download bin direnv https://github.com/direnv/direnv/releases/download/v2.37.1/direnv.linux-amd64\n</code></pre></p>"},{"location":"scripts/usage/#bash-strict-mode","title":"Bash strict mode","text":"<p>It should be compatible :) Use like this:</p> <pre><code>#!/bin/bash\n\n# Enable strict mode\nset -eu -o pipefail\n\n# Run or auto-install shxt.sh\n. shxt.sh || eval \"$(curl -v https://mrjk.github.io/shxt/shxt.sh); shxt_init\"\n</code></pre>"},{"location":"scripts/usage/#specific-readwrite-directory","title":"Specific read/write directory","text":"<p>It is possible to either use command option or environment variable.</p> <p>To implement.</p>"},{"location":"scripts/usage/#read-only-environments","title":"Read-only environments","text":"<p>This is not supported at the moment, eventually a reduced feature mode can be implemented.</p>"},{"location":"scripts/usage/#with-development-releasing","title":"With development releasing","text":"<p>Since the shell source code is directly published through website, it is possible to adapt for development mode. Start local instance:</p> <pre><code>cd docs\nmkdics serve\n</code></pre> <p>In script <pre><code>#!/bin/bash\n\neval \"$(curl -v http://127.0.0.1:8000/shxt/shxt.sh)\"; shxt_init\n</code></pre></p>"},{"location":"shell/install/","title":"Installation as shell manager","text":"<p>While shxt.sh can easily handle script dependencies, it can work with you shell instance. </p> <p>Auto install with curl: <pre><code>curl -v https://mrjk.github.io/shxt/shxt.sh | bash -s install home\nbash\n</code></pre></p>"},{"location":"shell/usage/","title":"Usage","text":"<p>Once shxt installed, you can use it.</p>"},{"location":"shell/usage/#examples","title":"Examples","text":"<p>Here are dropped some examples.</p>"},{"location":"shell/usage/#load-other-pieces-of-shell","title":"Load other pieces of shell","text":"<p>Here is a somewhat configuration:</p> <pre><code># .bashrc\n# File bashrc managed by shxt.sh\n\n# Run or auto-install shxt.sh\n. shxt.sh || eval \"$(curl -v https://mrjk.github.io/shxt/shxt.sh); shxt_init\"\n\n# My shell config as lib\nloader use lib bash_config https://raw.githubusercontent.com/USER/dotfiles/ref/head/master/.config/bash_config.sh\nloader use lib bash_ps1 https://raw.githubusercontent.com/USER/dotfiles/ref/head/master/.config/bash_ps1.sh\nloader use lib vim https://raw.githubusercontent.com/USER/dotfiles/ref/head/master/.config/vim.sh\n\n# Load bash config from lib\nload_bash_config\nload_ps1\nload_vim\n</code></pre>"},{"location":"shell/usage/#use-other-programs","title":"Use other programs","text":"<p>But it works for binary files as well:</p> <pre><code># My shell tools\nloader use bin yadm https://raw.githubusercontent.com/yadm-dev/yadm/refs/heads/master/yadm\nloader use bin has https://raw.githubusercontent.com/kdabir/has/refs/heads/master/has\nloader download bin spark https://raw.githubusercontent.com/holman/spark/refs/heads/master/spark\n\n# Configure my shell hooks\nloader use lib direnv https://raw.githubusercontent.com/USER/dotfiles/ref/head/master/.config/bash_direnv.sh\nloader use lib mise https://raw.githubusercontent.com/USER/dotfiles/ref/head/master/.config/bash_mise.sh\n\n# Always run a notice message\nlog INFO 'Shxt.sh managed'\n</code></pre>"},{"location":"shell/usage/#make-it-even-more-minimal","title":"Make it even more minimal","text":"<p>You can even compact the whole in one single file, executing other imports:</p> <pre><code># .bashrc\n# Minimal bashrc managed by shxt.sh\n\n# Run or auto-install shxt.sh\n. shxt.sh || eval \"$(curl -v https://mrjk.github.io/shxt/shxt.sh); shxt_init\"\n\n# My shell config as lib\nloader use lib my_super_bash_cfg https://raw.githubusercontent.com/USER/dotfiles/ref/head/master/.my_super_bash_cfg.sh\n\n# Then load a single function\nconfig_shell\n</code></pre>"},{"location":"shell/usage/#configuring-rcfiles","title":"Configuring rc.files","text":"<p>To implement.</p>"},{"location":"shell/usage/#disabling-temporarly","title":"Disabling temporarly","text":"<p>To implement</p>"},{"location":"shell/usage/#reload","title":"Reload","text":"<p>To implement</p>"},{"location":"shell/usage/#issues","title":"Issues","text":""},{"location":"shell/usage/#long-loading-time","title":"Long loading time","text":"<p>This can happen the first time when shxt is not installed or when shxt need to download other dependencies. Thus it maybe a good idea to keep your shxt.sh config minimalist, especially when starting for the first time a shell. This can be annoying in a shell context, or when the machine is slow to responds.</p> <p>Check also other comlplimentary tools such as direnv, mise, asdf, pkgx ...</p>"},{"location":"shell/usage/#rationale","title":"Rationale","text":"<p>The most problematic point is to modify .bashrc file to make things easily, and for two reasons:</p> <ul> <li>Sometimes the user does not have a writable path in $PATH, like <code>/home/USER/bin</code> or <code>/home/USER/.local/bin</code>. So you have to modify $PATH</li> <li>Sometimes you need to source shell snippets to make some apps to work. They basically inject code in your shell, like direnv, mise and many other shell tools.</li> </ul> <p>So .bashrc can quickly become messy and hard to maintain. What if now shxt.sh provides a way to quickly bootstrap various shell scripts in different ways ? Thus it become possible to use shxt.sh as bootstrap tool, to bootstrap more complex tools and so on.</p>"}]}