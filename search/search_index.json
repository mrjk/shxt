{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>Easily reuse code chunks across shell scripts.</p> <p>Release is available here https://mrjk.github.io/shxt/shxt.sh. <pre><code>eval \"$(curl -v https://mrjk.github.io/shxt/shxt.sh); shxt_init\"\n</code></pre></p> <p>Or in dev mode <pre><code>eval \"$(curl -v http://127.0.0.1:8000/shxt/shxt.sh)\"\n\nshxt_init\n</code></pre></p>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"install/","title":"Install","text":"<p>install code</p>"},{"location":"source/","title":"Source","text":""},{"location":"source/#binbash","title":"!/bin/bash","text":""},{"location":"source/#_1","title":"=============================================================","text":""},{"location":"source/#documentation","title":"Documentation","text":""},{"location":"source/#_2","title":"=============================================================","text":""},{"location":"source/#usage-api","title":"Usage API:","text":""},{"location":"source/#source-importsh-lib","title":"source import.sh ../lib","text":""},{"location":"source/#import-httpsrawgithubusercontentcomqzbisshmasterissh","title":"import https://raw.githubusercontent.com/qzb/is.sh/master/is.sh","text":""},{"location":"source/#import-myapp_lib1sh","title":"import myapp_lib1.sh","text":""},{"location":"source/#import-myapp_lib2sh","title":"import myapp_lib2.sh","text":""},{"location":"source/#packagesh-file-isshv112","title":"package.sh file is.sh@v1.1.2","text":""},{"location":"source/#see-httpsgithubcomdylanarapspure-bash-bibleblobmasterreadmemdget-the-terminal-size-in-lines-and-columns-from-a-script","title":"See: https://github.com/dylanaraps/pure-bash-bible/blob/master/README.md#get-the-terminal-size-in-lines-and-columns-from-a-script","text":""},{"location":"source/#a-vars-from-untouched-shell","title":"a vars from untouched shell:","text":""},{"location":"source/#bash-env-i-bash-norc-o-posix-c-set-less","title":"bash: ( env -i bash --norc -o posix -c set ) | less","text":""},{"location":"source/#sh-env-i-sh-norc-c-set","title":"sh: ( env -i sh --norc -c -- set )","text":""},{"location":"source/#_3","title":"=============================================================","text":""},{"location":"source/#libraries","title":"Libraries","text":""},{"location":"source/#_4","title":"=============================================================","text":""},{"location":"source/#portable-realpath-implementation-in-shell-script","title":"Portable realpath implementation in shell script","text":""},{"location":"source/#usage","title":"Usage:","text":""},{"location":"source/#realpath","title":"realpath []","text":""},{"location":"source/#example","title":"Example:","text":""},{"location":"source/#realpath-bash_source0","title":"realpath \"${BASH_SOURCE[0]}\"","text":""},{"location":"source/#realpath-binfile","title":"realpath ../bin/file","text":""},{"location":"source/#realpath_1","title":"realpath","text":""},{"location":"source/#source-httpsstackoverflowcoma45828988","title":"Source: https://stackoverflow.com/a/45828988 <p>realpath() (    # TOFIX: Verify this function still work in strict mode   # set -o errexit -o nounset   declare link=\"${1:-$PWD}\"</p> <p># Try with real realpath first   if command realpath \"$link\" 2&gt;/dev/null; then return; fi</p> <p># If it's a directory, just skip all this.   if cd \"$link\" 2&gt;/dev/null; then     pwd -P \"$link\"; return 0   fi</p> <p># Resolve until we are out of links (or recurse too deep).   declare n=0 limit=1024   while [[ -L $link ]] &amp;&amp; [[ $n -lt $limit ]]; do      n=$((n + 1))     cd \"$(dirname -- ${link})\" \\       &amp;&amp; link=\"$(readlink -- \"${link##/}\")\"   done; cd \"${link%/}\"</p> <p># Check limit recursion   [[ $n -lt $limit ]] || {     &gt;&amp;2 printf \"ERROR: Recursion limit ($limit) exceeded.\\n\"     return 2; }</p> <p>printf '%s/%s\\n' \"$(pwd -P)\" \"${link##*/}\" )</p>","text":""},{"location":"source/#add-a-to","title":"Add a  to","text":""},{"location":"source/#usage_1","title":"Usage:","text":""},{"location":"source/#varpath_prepend","title":"varpath_prepend","text":""},{"location":"source/#example_1","title":"Example:","text":""},{"location":"source/#varpath_prepend-path-pwdappbin","title":"varpath_prepend PATH $PWD/app/bin <p>varpath_append_force() {   local var=$1   local path=$2</p> <p>log TRACE \"Prepend to $var: $path\"   if [[ \":${!var}:\" != \":$path:\" ]]; then   # if [ -d \"$path\" ] &amp;&amp; [[ \":${!var}:\" != \":$path:\" ]]; then   #   log TRACE \"Add prepend to '$var': $path\"     export \"${var}=${!var:+\"${!var}:\"}$path\"</p> <p>fi } varpath_append() {   local var=$1   local path=$2</p> <p>if [ -d \"$path\" ]; then     varpath_append_force \"$var\" \"$path\"   else     log TRACE \"Skip directory for $var: $path\"   fi</p> <p>}</p>","text":""},{"location":"source/#add-a-to_1","title":"Add a  to","text":""},{"location":"source/#usage_2","title":"Usage:","text":""},{"location":"source/#varpath_append","title":"varpath_append","text":""},{"location":"source/#example_2","title":"Example:","text":""},{"location":"source/#varpath_append-path-pwdappbin","title":"varpath_append PATH $PWD/app/bin <p>varpath_prepend_force() {   local var=$1   local path=$2</p> <p>if [[ \":${!var}:\" != \":$path:\" ]]; then     log TRACE \"Append to $var: $path\"     export \"${var}=$path${!var:+\":${!var}\"}\"   else     log TRACE \"Already in path $var: $path\"     return 1   fi } varpath_prepend() {   local var=$1   local path=$2</p> <p>if [ -d \"$path\" ]; then     varpath_prepend_force \"$var\" \"$path\"   else     log TRACE \"Skip directory for $var: $path\"   fi</p> <p>}</p>","text":""},{"location":"source/#find-first-matching-file-called-in-list-of","title":"Find first matching file called  in list of","text":""},{"location":"source/#usage_3","title":"Usage:","text":""},{"location":"source/#varpath_find","title":"varpath_find   <p>varpath_find () {   local var_name=$1   local target=$2   local path=   log TRACE \"File lookup: '$target' from \\$${var_name}\"</p> <p>local paths=$(/usr/bin/tr ':' '\\n' &lt;&lt;&lt; \"${!var_name}\")   while read path ; do     file=\"$path/$target\"     if [[ -f \"$file\" ]]; then       log TRACE \"File lookup successed: $file\"       printf \"%s\\n\" \"$file\"       return 0     else       log TRACE \"File lookup failed: $file\"     fi   done &lt;&lt;&lt;\"$paths\"   log TRACE \"Could not find file '$target' in '\\$${var_name}'\"   # &gt;&amp;2 printf \"%s\\n\" \"WARN: Could not find file '$target' in \"${var_name}\"\"   return 1 }</p> <p>varpath_find2 () {   local var_name=$1   local target=$2   local path=   log TRACE \"File lookup: '$target' from \\$${var_name}\"</p> <p>local paths=$(/usr/bin/tr ':' '\\n' &lt;&lt;&lt; \"${!var_name}\")   while read path ; do     file=\"$path/$target\"     if [[ -f \"$file\" ]]; then       log TRACE \"File lookup successed: $file\"       printf \"%s\\n\" \"$file\"       return 0     else       log TRACE \"File lookup failed: $file\"     fi   done &lt;&lt;&lt;\"$paths\"   log TRACE \"Could not find file '$target' in '\\$${var_name}'\"   # &gt;&amp;2 printf \"%s\\n\" \"WARN: Could not find file '$target' in \"${var_name}\"\"   return 1 }</p>","text":""},{"location":"source/#find-all-writable-or-parents-dirs-and-return-a-colon-separated-string-result","title":"Find all writable or parents dirs and return a colon separated string result","text":""},{"location":"source/#usage_4","title":"Usage:","text":""},{"location":"source/#varpath_find_rw_dir","title":"varpath_find_rw_dir [...] <p>varpath_find_rw_dir () {   local target=($@)   if [[ \"$@\" == '-' ]] ; then     # Read from stdin     local target=() line=     # exec &lt; &lt;(printf '%s\\n' \"$@\")     while IFS= read -r line; do       [ -z \"$line\" ] || target+=($line)     done &lt;&lt;&lt;\"$(cat /dev/stdin)\"   fi   local i=0   local result=''   while (( i &lt; ${#target[@]} )); do       local path=\"${target[i]}\"       local parent=${path%/*}       if [ -d \"$path\" ]; then         if [ -w \"$path\" ]; then           result=\"${result:+$result:}$path\"         fi       elif [ -d \"$parent\" ]; then         if [ -w \"$parent\" ]; then           result=\"${result:+$result:}$path\"         fi       fi       ((i++))   done   printf \"%s\" \"$result\" }</p>","text":""},{"location":"source/#test-if-shell-is-executed-or-sourced","title":"Test if shell is executed or sourced","text":""},{"location":"source/#if-bash_source0-0-then","title":"# if [[ \"${BASH_SOURCE[0]}\" =~ .*\"$0\"$ ]]; then","text":""},{"location":"source/#if-bash_source0-0-then_1","title":"if [[ \"${BASH_SOURCE[0]}\" == \"$0\" ]]; then","text":""},{"location":"source/#echo-executed","title":"echo EXECUTED","text":""},{"location":"source/#else","title":"else","text":""},{"location":"source/#echo-sourced","title":"echo SOURCED","text":""},{"location":"source/#fi","title":"fi","text":""},{"location":"source/#return-true-if-context-is-executed","title":"Return true if context is executed <p>shell_is_executed () {   [[ \"${BASH_SOURCE[0]}\" == \"$0\" ]] }</p>","text":""},{"location":"source/#return-false-if-context-is-sourced","title":"Return false if context is sourced <p>shell_is_sourced () {   ! shell_is_executed }</p>","text":""},{"location":"source/#return-false-if-context-is-sourced_1","title":"Return false if context is sourced <p>shell_is_known () {   local name=$1   case \"$name\" in     /sh) echo \"$name\" ;;      /ash) echo \"$name\" ;;      /bash) echo \"$name\" ;;      /zsh) echo \"$name\" ;;      *) return 1;;    esac }</p>","text":""},{"location":"source/#sources","title":"Sources:","text":""},{"location":"source/#httpsserverfaultcomquestions146745how-can-i-check-in-bash-if-a-shell-is-running-in-interactive-mode","title":"https://serverfault.com/questions/146745/how-can-i-check-in-bash-if-a-shell-is-running-in-interactive-mode","text":""},{"location":"source/#return-true-if-terminal-stdin-is-interactive-terminal","title":"Return true if terminal stdin is interactive terminal <p>shell_is_interactive () {   [ -t 0 ] }</p>","text":""},{"location":"source/#return-true-if-terminal-stdin-is-not-interactive","title":"Return true if terminal stdin is not interactive <p>shell_is_not_interactive () {   ! [ -t 0 ] }</p>","text":""},{"location":"source/#source-a-shell-file","title":"Source a shell file <p>shell_source () {   local path=$1   shift 1 || true   local rc=0</p> <p>PWD=\"${path%/*}\" . \"$path\" $@ || \\     {       rc=$?       &gt;&amp;2 printf \"Failed to load lib returned $rc: %s\\n\" \"$p\"     }   return $rc }</p>","text":""},{"location":"source/#download-an-into-or-stdout","title":"Download an  into  or stdout","text":""},{"location":"source/#usage_5","title":"Usage:","text":""},{"location":"source/#download_file","title":"download_file","text":""},{"location":"source/#download_file_1","title":"download_file   <p>download_file() {   local url=$1   local filename=${2:--}</p> <p>if [ -z \"$url\" ]; then       echo \"Usage: download_file  []\"       return 1   fi <p># Create destination dir   if [ \"$filename\" != '-' ]; then     local parent=\"${filename%/*}\"     [[ -d \"${parent}\" ]] || mkdir -p \"${parent}\"   fi</p> <p># Find download tool   local rc=0   if command -v curl &gt; /dev/null; then       curl -L -s -o \"$filename\" \"$url\" || rc=$?       if [[ $rc -ne 0 ]]; then         log WARN \"Failure after curl: $rc\"         return 1       fi   elif command -v wget &gt; /dev/null; then       wget -O \"$filename\" \"$url\"   else       printf \"%s\\n\" \"Neither curl nor wget is installed. Please install one of them to use this function.\"       return 1   fi</p> <p># Report   if [ $? -ne 0 ]; then     &gt;&amp;2 printf \"ERROR: Failed to download the file: %s\\n\" \"$url\"     return 1   else     log TRACE \"File downloaded successfully as: $filename\"   fi }</p>","text":""},{"location":"source/#shxt_log_levelshxt_log_level-info-dry-debug-trace","title":"SHXT_LOG_LEVEL=${SHXT_LOG_LEVEL:-INFO}  # DRY, DEBUG, TRACE","text":""},{"location":"source/#shxt_log_scaletracedebugruninfodryhintnoticecmduserwarnerrerrorcrittododiequitprompt","title":"SHXT_LOG_SCALE=\"TRACE:DEBUG:RUN:INFO:DRY:HINT:NOTICE:CMD:USER:WARN:ERR:ERROR:CRIT:TODO:DIE:QUIT:PROMPT\"","text":""},{"location":"source/#cli-libraries","title":"CLI libraries","text":""},{"location":"source/#_5","title":"=================","text":""},{"location":"source/#validate-log-level-pass-aginst-limit","title":"Validate log level pass aginst limit <p>_log_validate_level () {   local SHXT_LOG_SCALE=\"${SHXT_LOG_SCALE:-TRACE:DEBUG:INFO:NOTICE:WARN:ERR:ERROR:CRIT:TODO:DIE:QUIT:PROMPT}\"</p> <p>local level=$1   local limit_level=${2:-${SHXT_LOG_SCALE%%:*}}</p> <p>if [[ ! \":${SHXT_LOG_SCALE#*$limit_level:}:$limit_level:\" =~ :\"$level\": ]]; then     if [[ ! \":${SHXT_LOG_SCALE}\" =~ :\"$level\": ]]; then       &gt;&amp;2 printf \"%s\\n\" \"  BUG: Unknown log level: $level\"     fi     return 1   fi }</p>","text":""},{"location":"source/#logging-support-with-levels","title":"Logging support, with levels <p>log ()  {   local SHXT_LOG_LEVEL=${SHXT_LOG_LEVEL:-INFO}</p> <p>local old_setting=${-//[^x]/}; set +x   local level=\"${1:-DEBUG}\"   shift 1 || true</p> <p># Check log level filter   if _log_validate_level \"$level\" \"$SHXT_LOG_LEVEL\"; then</p> <pre><code>local msg=${*}\nif [[ \"$msg\" == '-' ]]; then\n  msg=\"$(cat -)\"\nfi\nwhile read -r -u 3 line; do\n  &gt;&amp;2 printf \"%6s: %s\\\\n\" \"$level\" \"${line:- }\"\ndone 3&lt;&lt;&lt;\"$msg\"\n</code></pre> <p>fi</p> <p># Restore trace mode if was enabled   if [[ -n \"${old_setting-}\" ]]; then set -x; else set +x; fi }</p>","text":""},{"location":"source/#terminate-all-with-error-message-and-rc-code","title":"Terminate all with error message and rc code <p>log_die () {     local rc=${1:-1}     shift 1 || true     local msg=\"${*:-}\"     local prefix=DIE     [[ \"$rc\" -eq 0 ]] || prefix=DIE     if [[ -z \"$msg\" ]]; then       [ \"$rc\" -ne 0 ] || exit 0       log \"$prefix\" \"Program terminated with error: $rc\"     else       log \"$prefix\" \"$msg\"     fi</p> <pre><code># Remove EXIT trap and exit nicely\ntrap '' EXIT\nexit \"$rc\"\n</code></pre> <p>}</p>","text":""},{"location":"source/#_6","title":"=============================================================","text":""},{"location":"source/#internal-libraries-registries","title":"Internal libraries: Registries","text":""},{"location":"source/#_7","title":"=============================================================","text":""},{"location":"source/#register-library","title":"Register library","text":""},{"location":"source/#usage-loader_register-store-path-name","title":"Usage: loader_register STORE PATH [NAME] <p>loader_register() {   local store_name=$1   local store=${!store_name}   local path=$2   local file=${3:-${path##/}}   local dir=${path%/}</p> <p># # Do initial load   # if [[ -z \"${SHLIB-}\" ]]; then   #   SHSRC=$path   #   SHSRC_FILE=$file   #   SHSRC_DIR=$dir   # fi</p> <p># Check if lib is not already registered   # [[ \":${store-}:\" != :$file: ]] || {   [[ \":${store-}:\" != :$file=:* ]] || {     &gt;&amp;2 printf \"Item already registered: %s\\n\" \"$file\"     return 1   }</p> <p># Add module into SHLIB   declare -g \"$store_name\"=\"${store:+$store:}$file=$path\"</p> <p># Importing vars   _IMPORT_PATH=$path   _IMPORT_FILE=$file   _IMPORT_DIR=$dir }</p>","text":""},{"location":"source/#_8","title":"=============================================================","text":""},{"location":"source/#init-loader","title":"Init Loader","text":""},{"location":"source/#_9","title":"=============================================================","text":""},{"location":"source/#prepare-importsh-environment","title":"Prepare import.sh environment <p>shxt_init() {</p> <p>local auto_install=true   local auto_update=true   local debug=false   local trace=false   local OPTIND=0   while getopts 'dxuUlL' opt; do     case ${opt} in       d)         debug=true         ;;       x)         trace=true         ;;       u)         auto_update=true         ;;       U)         auto_update=false         ;;       l)         auto_install=true         ;;       L)         auto_install=false         ;;       ?)         log ERROR \"Invalid option: -${OPTARG}.\"         return 1         ;;     esac     OPTIND=$((OPTIND + 1))   done   OPTIND=$((OPTIND - 1))   shift \"$OPTIND\"</p> <p># Enable flags   if [[ \"$debug\" == true ]]; then     SHXT_LOG_LEVEL=TRACE     log INFO \"shxt.sh debug mode enabled\"   fi   if [[ \"$trace\" == true ]]; then     set -x   fi</p> <p># Init core   local d=${1-} # ${1:-$(ps -o args= $$)}</p> <p>local path=$(realpath \"$0\")   local root=\"${path%/*}${d:+/$d}\"</p> <p># Autodetect current installation</p> <p>local install_path=$(command -v \"shxt.sh\" 2&gt;/dev/null)   local need_update=false   if [[ \"$auto_install\" == true ]] &amp;&amp; [[ ! -x \"$install_path\" ]] ; then     # Auto install in PATH if not installed     log INFO \"Auto-installing shxt.sh\"     if _loader2__install; then       need_update=true     fi</p> <p>elif [[ \"$auto_update\" == true ]] &amp;&amp; [[ -x \"$install_path\" ]] ; then     # Run auto update ...     local max_days=7     local max_age_ts=$(date -d \"now - $max_days days\" +%s)     local last_update_ts=$(date -r \"$install_path\" +%s)     if (( last_update_ts &lt;= max_age_ts )); then       # echo \"$filename is older than 100 days\"       log INFO \"Auto-updating shxt.sh because older than $max_days days\"       if _loader2__install; then         need_update=true       fi     else       log TRACE \"No need to update, newer than $max_days days\"     fi   fi</p> <p>set -x</p> <p># Reload code   if [[ \"$need_update\" == true ]]; then     log TRACE \"Reloading shxt source code\"     install_path=$(command -v \"shxt.sh\" 2&gt;/dev/null)     . \"$install_path\"   fi   export SHXT_INSTALL_PATH=$install_path</p> <p># set +x</p> <p># Auto-register into SHLIB or quit   export SHXT_LIBS=''   loader_register SHXT_LIBS \"$path\" shxt.sh || return 0   export SHXT_VERSION=0.0.1   export SHXT_NEEDLE=${SHXT_NEEDLE:-${USER}-$(cksum &lt;&lt;&lt; \"$path\" | cut -f 1 -d ' ')}</p> <p># Find most suitable RW path   export SHXT_DATA_DIRS=$(varpath_find_rw_dir \\     \"$HOME/.local/share/shxt\" \\     \"$HOME/.tmp/shxt\" \\     \"/tmp/\" \\     \"/dev/shm/\" \\     \"$root/cache/\" \\     \"$root/tmp/\"     )</p> <p># Keep only first writable dir and append program needle   export SHXT_RW_PATH=\"${SHXT_DATA_DIRS%%:*}${SHXT_DATA_DIRS:+/$SHXT_NEEDLE}\"</p> <p># Etra dirs   export SHXT_DIR_BIN=${SHXT_RW_PATH:+$SHXT_RW_PATH/bin}   export SHXT_DIR_LIB=${SHXT_RW_PATH:+$SHXT_RW_PATH/lib}   export SHXT_DIR_FILES=${SHXT_RW_PATH:+$SHXT_RW_PATH/files}</p> <p>[ -d \"${SHXT_DIR_BIN:-}\" ] || mkdir -p \"${SHXT_DIR_BIN}\"   [ -d \"${SHXT_DIR_LIB:-}\" ] || mkdir -p \"${SHXT_DIR_LIB}\"   [ -d \"${SHXT_DIR_FILES:-}\" ] || mkdir -p \"${SHXT_DIR_FILES}\"</p> <p># return 1</p> <p># # Prepare lookup paths</p> <p>export SHXT_LIB_PATHS=   # varpath_append SHXT_LIB_PATHS \"$root/lib\"   # varpath_append SHXT_LIB_PATHS \"$root/libexec\"   # varpath_append SHXT_LIB_PATHS \"$root\"   # varpath_append SHXT_LIB_PATHS \"$SHXT_DIR_SHARED/lib\"   # varpath_append SHXT_LIB_PATHS \"$SHXT_DIR_DOWNLOADS/$SHXT_NEEDLE/lib\"</p> <p># export SHXT_FILE_PATHS=   # varpath_append SHXT_FILE_PATHS \"$root/share\"   # varpath_append SHXT_FILE_PATHS \"$root\"   # varpath_append SHXT_FILE_PATHS \"$SHXT_DIR_SHARED/share\"   # varpath_append SHXT_FILE_PATHS \"$SHXT_DIR_DOWNLOADS/$SHXT_NEEDLE/files\"</p> <p>export SHXT_BIN_PATHS=$PATH   # varpath_prepend SHXT_BIN_PATHS \"/usr/local/sbin/\"   # varpath_prepend SHXT_BIN_PATHS \"/usr/local/bin/\"   # varpath_prepend SHXT_BIN_PATHS \"$HOME/bin\"   # varpath_prepend_force SHXT_BIN_PATHS \"$HOME/.local/bin\"   # varpath_prepend_force SHXT_BIN_PATHS \"$HOME/.local/scripts\"</p> <p>varpath_prepend SHXT_BIN_PATHS \"$root/bin\"   varpath_prepend SHXT_BIN_PATHS \"$root\"   varpath_prepend SHXT_BIN_PATHS \"$SHXT_DIR_BIN\"   varpath_prepend SHXT_BIN_PATHS \"$SHXT_DIR_SHARED/bin\"   # varpath_prepend SHXT_BIN_PATHS \"$SHXT_DIR_DOWNLOADS/$SHXT_NEEDLE/bin\"</p> <p>varpath_prepend SHXT_BIN_PATHS \"$SHXT_RW_PATH\"</p> <p># log WARN \"PATH DIRS: $SHXT_BIN_PATHS\"</p> <p># Self register and init   # export SHXT_BIN_PATHS_OLD=${SHXT_BIN_PATHS_OLD:-$PATH}   # export SHXT_FILE_MAP=   # export SHLIB=   # export SHXT_LIBS='toto:titi'</p> <p># echo \"RET=$(shell_is_known $path)\"   # return 1   # loader_register SHXT_LIBS \"$path\" </p> <p># export PATH=$SHXT_BIN_PATHS</p> <p>log TRACE \"shxt.sh inited: $SHXT_RW_PATH\"</p> <p>}</p>","text":""},{"location":"source/#ensure-shxtsh-is-installed-gloabally","title":"Ensure shxt.sh is installed gloabally <p>_loader2__install () {</p> <p>local dest=${1:-}   # local url=\"https://mrjk.github.io/shxt/shxt.sh\"   # local url=\"https://mrjk.github.io/shxt/v.1/shxt.sh\"   local url=\"https://raw.githubusercontent.com/mrjk/shxt/refs/heads/main/shxt.sh\"</p> <p>local force=false   while getopts ':f' opt; do     case ${opt} in       f)         force=true         ;;       ?)         log ERROR \"Invalid option: -${OPTARG}.\"         return 1         ;;     esac   done</p> <p># Quit if already installed   local existing=$(command -v \"shxt.sh\" 2&gt;/dev/null)   if [[ -x \"$existing\" ]] ; then     if [[ \"$force\" != true ]]; then       log TRACE \"shxt.sh already installed in $existing\"       return 0     fi   fi</p> <p># Detect install path   local result=   if [ -n \"$dest\" ]; then     dest=$(varpath_find_rw_dir \"$dest\")   else</p> <pre><code>dest=$(tr ':' '\\n' &lt;&lt;&lt; \"$PATH\" | tac | varpath_find_rw_dir -)\ndest=${dest%%:*}\n</code></pre> <p>fi</p> <p># Ensure destination dir exists   [ -d \"$dest\" ] || mkdir -p \"$dest\"   if [ ! -w \"$dest\" ] ; then     log ERROR \"Impossible to install or write in path: $dest\"     return 1   fi</p> <p># Ensure a file has been updated   local _shxt_ctx_target_download_path=\"$dest/shxt.sh\"   log INFO \"Downloading $_shxt_ctx_target_download_path from $url ...\"   if download_file \"$url\" \"$_shxt_ctx_target_download_path\"; then     chmod +x \"$_shxt_ctx_target_download_path\"</p> <pre><code>log INFO \"shxt.sh installed in $dest\"\n</code></pre> <p>else     log ERROR \"Failed to install shxt.sh\"     return 1   fi }</p> <p>_loader2__init () {   echo \"Init or reconfigure shxt $@\" }</p> <p>_loader2__clean () {   echo \"Clean shxt $@\" }</p>","text":""},{"location":"source/#_10","title":"=============================================================","text":""},{"location":"source/#new-api-v2-helpers","title":"NEW API V2 helpers","text":""},{"location":"source/#_11","title":"============================================================= <p>loader2__ctx_clean () {   unset ${!_shxt_ctx*} }</p> <p>_loader2__ctx_init () {</p> <p>export _shxt_ctx_kind=$1   export _shxt_ctx_target=$2   export _shxt_ctx_target_installed=false   export _shxt_ctx_target_downloaded=false</p> <p>export _shxt_ctx_store_name=   export _shxt_ctx_store_paths=</p> <p>export _shxt_ctx_target_download_dir=   export _shxt_ctx_target_download_path=   export _shxt_ctx_target_dir=   export _shxt_ctx_target_path=</p> <p># source_url=${3:-}</p> <p>case \"$_shxt_ctx_kind\" in     bin)       _shxt_ctx_store_name=SHXT_BIN_PATHS       _shxt_ctx_target_download_dir=${SHXT_RW_PATH:+$SHXT_RW_PATH/bin}       # path_suffix=\"$SHXT_DIR_BIN\"       ;;     lib)       _shxt_ctx_store_name=SHXT_LIB_PATHS       _shxt_ctx_target_download_dir=${SHXT_RW_PATH:+$SHXT_RW_PATH/lib}       # path_suffix=\"$SHXT_DIR_LIB\"       ;;     file)       _shxt_ctx_store_name=SHXT_FILE_PATHS       _shxt_ctx_target_download_dir=${SHXT_RW_PATH:+$SHXT_RW_PATH/files}       # path_suffix=\"$SHXT_DIR_FILES\"        ;;     *)        &gt;&amp;2 printf \"_loader2__ctx_init does not support kind '%s', please use one of: %s\\n\" \"$_shxt_ctx_kind\" \"bin, lib or file\"       return 8     ;;   esac</p> <p># Ensure path is always up to date   export PATH=$SHXT_BIN_PATHS</p> <p># Set custom paths   _shxt_ctx_store_paths=${!_shxt_ctx_store_name}   _shxt_ctx_target_download_path=${_shxt_ctx_target_download_dir:+$_shxt_ctx_target_download_dir/$_shxt_ctx_target}</p> <p># Lookup if not downloaded   if [ -f \"$_shxt_ctx_target_download_path\" ]; then     _shxt_ctx_target_path=\"$_shxt_ctx_target_download_path\"     _shxt_ctx_target_downloaded=true   else     _shxt_ctx_target_path=$(varpath_find2 \"$_shxt_ctx_store_name\" \"$_shxt_ctx_target\" || true)   fi</p> <p># Report if installed   _shxt_ctx_target_dir=${_shxt_ctx_target_path%/*}   if [ -f \"$_shxt_ctx_target_path\" ]; then     _shxt_ctx_target_installed=true   fi</p> <p>}</p>","text":""},{"location":"source/#_12","title":"======================","text":""},{"location":"source/#new-api-v2-loader","title":"NEW API V2 LOADER","text":""},{"location":"source/#_13","title":"====================== <p>_loader2__download () {   _loader2__ctx_init \"$@\"   shift 2   local url=${1:-}</p> <p># Ensure URL is available   if [ -z \"$url\" ]; then     log CRIT \"Missing URL for $_shxt_ctx_target !\"     return 1   fi</p> <p>if [ \"$_shxt_ctx_target_downloaded\" != true ]; then     # log INFO \"Downloading $_shxt_ctx_target ...\"     _loader2__update \"$_shxt_ctx_kind\" \"$_shxt_ctx_target\" \"$url\"   # else   #   log INFO \"Using downloaded $_shxt_ctx_target ...\"   fi</p> <p>}</p> <p>_loader2__update () {   _loader2__ctx_init \"$@\"   shift 2   local url=${1:-}</p> <p># Ensure URL is available   if [ -z \"$url\" ]; then     log CRIT \"Missing URL for $_shxt_ctx_target !\"     return 1   fi</p> <p># Ensure a file has been updated   log INFO \"Downloading $_shxt_ctx_target from $url ...\"   download_file \"$url\" \"$_shxt_ctx_target_download_path\"   if [ \"$_shxt_ctx_kind\" == bin ]; then     chmod +x \"$_shxt_ctx_target_download_path\"   fi }</p> <p>_loader2__use () {   _loader2__ctx_init \"$@\"   shift 2   local url=${1:-}</p> <p>if [ \"$_shxt_ctx_target_installed\" != true ]; then     _loader2__update \"$_shxt_ctx_kind\" \"$_shxt_ctx_target\" \"$url\"   fi</p> <p># Enable the thing ...   case \"$_shxt_ctx_kind\" in     lib)       local old_cd=$PWD       log INFO \"Sourcing lib $_shxt_ctx_target_path\"       cd \"${_shxt_ctx_target_dir}\"       . \"${_shxt_ctx_target_path}\"       cd \"${old_cd}\"       ;;     file) ;;   esac</p> <p>}</p> <p>_loader2__path () {   _loader2__ctx_init \"$@\"   printf '\\s' \"$_shxt_ctx_target_path\" }</p> <p>_loader2__cat () {   _loader2__ctx_init \"$@\"   if [ -f \"$_shxt_ctx_target_path\" ]; then     cat \"$_shxt_ctx_target_path\"   fi   return 1 }</p> <p>_loader2__help_cli () {   cat &lt;&lt;EOF Mode: Executed Usage: $0 --help   $0 version   $0 help   $0 install [PATH]         Install/update automatically in PATH</p> <p>Infos:   SHXT_INSTALL_PATH=$SHXT_INSTALL_PATH EOF</p> <p>}</p> <p>_loader2__help_api () {   cat &lt;&lt;EOF Mode: Sourced Usage: . $0   $0 version   $0 help   $0 install [PATH]         Install/update automatically in PATH</p> <p>$0 use [bin|lib|file] [NAME] [PATH]         Use an item, locally or remotely   $0 download [bin|lib|file] [NAME] [PATH]    Download an item   $0 update [bin|lib|file] [NAME] [PATH]      Always update an item</p> <p>Infos:   SHXT_INSTALL_PATH=$SHXT_INSTALL_PATH</p> <p>EOF</p> <p>}</p> <p>loader_cli () {   local action=$1   case \"$action\" in     help|--help|-h)       _loader2__help_cli       return $?     ;;   esac</p> <p>loader \"$@\"</p> <p>}</p>","text":""},{"location":"source/#main-api","title":"Main API <p>loader () {   local action=$1   shift 1</p> <p>case \"$action\" in     version)       printf '%s\\n' \"1.0.0\"       return $?     ;;     install)       _loader2__install \"$@\"       return $?     ;;     init|conf)       _loader2__init \"$@\"       return $?     ;;     app|start|clean)       _loader2__clean \"$@\"       return $?     ;;   esac</p> <p>case \"$action\" in     # Behavioral settings     download|install)       _loader2__download \"$@\"     ;;     update)       _loader2__update \"$@\"     ;;     use|source|enable)       _loader2__use \"$@\"     ;;</p> <pre><code># Informative API\npath)\n  _loader2__path \"$@\"\n;;\ncat)\n  _loader2__cat \"$@\"\n;;\n\n*) \n  &gt;&amp;2 printf \"loader_use does not support action '%s', please use one of: %s\\n\" \"$action\" \"bin, lib or file\"\n  return 8\n;;\n</code></pre> <p>esac</p> <p>_loader2__ctx_clean</p> <p>}</p> <p>loader2 ()  {   loader \"$@\" }</p>","text":""},{"location":"source/#_14","title":"=============================================================","text":""},{"location":"source/#internal-libraries","title":"Internal libraries","text":""},{"location":"source/#_15","title":"=============================================================","text":""},{"location":"source/#_16","title":"# =============================================================","text":""},{"location":"source/#script-loader","title":"# Script loader","text":""},{"location":"source/#_17","title":"# =============================================================","text":""},{"location":"source/#if-bash_source0-0-then_2","title":"# if [[ \"${BASH_SOURCE[0]}\" =~ .*\"$0\"$ ]]; then","text":""},{"location":"source/#if-bash_source0-0-then_3","title":"if [[ \"${BASH_SOURCE[0]}\" == \"$0\" ]]; then","text":""},{"location":"source/#2-printf-0-is-not-meant-to-be-called-but-sourced-in-shell-scripts-see-help-usage-belownn","title":"&gt;&amp;2 printf \"$0 is not meant to be called, but sourced in shell scripts. See help usage below:\\n\\n\"","text":""},{"location":"source/#import__help","title":"import__help","text":""},{"location":"source/#exit-1","title":"exit 1","text":""},{"location":"source/#else_1","title":"else","text":""},{"location":"source/#shxt_init","title":"shxt_init \"$@\"","text":""},{"location":"source/#fi_1","title":"fi","text":""},{"location":"source/#use-cases","title":"Use cases:","text":""},{"location":"source/#eval-cat-shxtsh","title":"eval \"$(cat ../shxt.sh)\"","text":""},{"location":"source/#if-bash_source0-0-then_4","title":"if [[ \"${BASH_SOURCE[0]}\" =~ .*\"$0\"$ ]]; then <p>if [[ \"${BASH_SOURCE[0]}\" == \"$0\" ]]; then</p> <p># shxt_init   shxt_init   loader_cli \"$@\"</p> <p>else   shxt_init \"$@\"</p> <p>fi</p>","text":""}]}