{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>Easily reuse code chunks across shell scripts.</p> <p>Release is available here https://mrjk.github.io/shxt/shxt.sh. <pre><code>eval \"$(curl -v https://mrjk.github.io/shxt/shxt.sh); shxt_init\"\n</code></pre></p> <p>Or in dev mode <pre><code>eval \"$(curl -v http://127.0.0.1:8000/shxt/shxt.sh)\"\n\nshxt_init\n</code></pre></p>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"install/","title":"Install","text":"<p>install code</p> <pre><code>curl -v https://mrjk.github.io/shxt/shxt.sh | bash -s install\n</code></pre>"},{"location":"install/#debian","title":"Debian","text":"<pre><code>apt update; apt install -y bash curl\ncurl -v https://mrjk.github.io/shxt/shxt.sh | bash -s install\n</code></pre>"},{"location":"source/","title":"Source","text":"<p>This is the full code of shxt.sh. You can also fetch it with curl on https://mrjk.github.io/shxt/shxt.sh.</p> <pre><code>#!/bin/bash\n\n\n# =============================================================\n# Documentation\n# =============================================================\n\n# Usage API:\n# source import.sh ../lib\n# import https://raw.githubusercontent.com/qzb/is.sh/master/is.sh\n# import myapp_lib1.sh\n# import myapp_lib2.sh\n\n# package.sh file is.sh@v1.1.2 \n\n# See: https://github.com/dylanaraps/pure-bash-bible/blob/master/README.md#get-the-terminal-size-in-lines-and-columns-from-a-script\n\n# a vars from untouched shell: \n# bash: ( env -i bash --norc -o posix -c set ) | less\n# sh: ( env -i sh --norc -c -- set )\n\n\n# =============================================================\n# Libraries\n# =============================================================\n\n# Portable realpath implementation in shell script\n# Usage:\n#  realpath [&lt;PATH&gt;]\n# Example:\n#  realpath \"${BASH_SOURCE[0]}\"\n#  realpath ../bin/file\n#  realpath\n# Source: https://stackoverflow.com/a/45828988\nrealpath()\n( \n  # TOFIX: Verify this function still work in strict mode\n  # set -o errexit -o nounset\n  declare link=\"${1:-$PWD}\"\n\n  # Try with real realpath first\n  if command realpath \"$link\" 2&gt;/dev/null; then return; fi\n\n  # If it's a directory, just skip all this.\n  if cd \"$link\" 2&gt;/dev/null; then\n    pwd -P \"$link\"; return 0\n  fi\n\n  # Resolve until we are out of links (or recurse too deep).\n  declare n=0 limit=1024\n  while [[ -L $link ]] &amp;&amp; [[ $n -lt $limit ]]; do \n    n=$((n + 1))\n    cd \"$(dirname -- ${link})\" \\\n      &amp;&amp; link=\"$(readlink -- \"${link##*/}\")\"\n  done; cd \"${link%/*}\"\n\n  # Check limit recursion\n  [[ $n -lt $limit ]] || {\n    &gt;&amp;2 printf \"ERROR: Recursion limit ($limit) exceeded.\\n\"\n    return 2; }\n\n  printf '%s/%s\\n' \"$(pwd -P)\" \"${link##*/}\"\n)\n\n\n# Add a &lt;PATH&gt; to &lt;PATHS_VAR&gt;\n# Usage:\n#  varpath_prepend &lt;PATHS_VAR&gt; &lt;PATH&gt;\n# Example:\n#  varpath_prepend PATH $PWD/app/bin\nvarpath_append_force() {\n  local var=$1\n  local path=$2\n\n  log TRACE \"Prepend to $var: $path\"\n  if [[ \":${!var}:\" != *\":$path:\"* ]]; then\n  # if [ -d \"$path\" ] &amp;&amp; [[ \":${!var}:\" != *\":$path:\"* ]]; then\n  #   log TRACE \"Add prepend to '$var': $path\"\n    export \"${var}=${!var:+\"${!var}:\"}$path\"\n\n  fi\n}\nvarpath_append() {\n  local var=$1\n  local path=$2\n\n  if [ -d \"$path\" ]; then\n    varpath_append_force \"$var\" \"$path\"\n  else\n    log TRACE \"Skip directory for $var: $path\"\n  fi\n\n}\n\n\n# Add a &lt;PATH&gt; to &lt;PATHS_VAR&gt;\n# Usage:\n#  varpath_append &lt;PATHS_VAR&gt; &lt;PATH&gt;\n# Example:\n#  varpath_append PATH $PWD/app/bin\nvarpath_prepend_force() {\n  local var=$1\n  local path=$2\n\n  if [[ \":${!var}:\" != *\":$path:\"* ]]; then\n    log TRACE \"Append to $var: $path\"\n    export \"${var}=$path${!var:+\":${!var}\"}\"\n  else\n    log TRACE \"Already in path $var: $path\"\n    return 1\n  fi\n}\nvarpath_prepend() {\n  local var=$1\n  local path=$2\n\n  if [ -d \"$path\" ]; then\n    varpath_prepend_force \"$var\" \"$path\"\n  else\n    log TRACE \"Skip directory for $var: $path\"\n  fi\n\n}\n\n\n# Find first matching file called &lt;NAME&gt; in list of &lt;PATHS_VAR&gt;\n# Usage:\n#  varpath_find &lt;PATHS_VAR&gt; &lt;NAME&gt;\nvarpath_find ()\n{\n  local var_name=$1\n  local target=$2\n  local path=\n  log TRACE \"File lookup: '$target' from \\$${var_name}\"\n\n  local paths=$(/usr/bin/tr ':' '\\n' &lt;&lt;&lt; \"${!var_name}\")\n  while read path ; do\n    file=\"$path/$target\"\n    if [[ -f \"$file\" ]]; then\n      log TRACE \"File lookup successed: $file\"\n      printf \"%s\\n\" \"$file\"\n      return 0\n    else\n      log TRACE \"File lookup failed: $file\"\n    fi\n  done &lt;&lt;&lt;\"$paths\"\n  log TRACE \"Could not find file '$target' in '\\$${var_name}'\"\n  # &gt;&amp;2 printf \"%s\\n\" \"WARN: Could not find file '$target' in \"${var_name}\"\"\n  return 1\n}\n\nvarpath_find2 ()\n{\n  local var_name=$1\n  local target=$2\n  local path=\n  log TRACE \"File lookup: '$target' from \\$${var_name}\"\n\n  local paths=$(/usr/bin/tr ':' '\\n' &lt;&lt;&lt; \"${!var_name}\")\n  while read path ; do\n    file=\"$path/$target\"\n    if [[ -f \"$file\" ]]; then\n      log TRACE \"File lookup successed: $file\"\n      printf \"%s\\n\" \"$file\"\n      return 0\n    else\n      log TRACE \"File lookup failed: $file\"\n    fi\n  done &lt;&lt;&lt;\"$paths\"\n  log TRACE \"Could not find file '$target' in '\\$${var_name}'\"\n  # &gt;&amp;2 printf \"%s\\n\" \"WARN: Could not find file '$target' in \"${var_name}\"\"\n  return 1\n}\n\n\n# Find all writable or parents dirs and return a colon separated string result\n# Usage:\n#  varpath_find_rw_dir [&lt;PATHS&gt;...]\nvarpath_find_rw_dir ()\n{\n  local target=($@)\n  if [[ \"$@\" == '-' ]] ; then\n    # Read from stdin\n    local target=() line=\n    # exec &lt; &lt;(printf '%s\\n' \"$@\")\n    while IFS= read -r line; do\n      [ -z \"$line\" ] || target+=($line)\n    done &lt;&lt;&lt;\"$(cat /dev/stdin)\"\n  fi\n  local i=0\n  local result=''\n  while (( i &lt; ${#target[@]} )); do\n      local path=\"${target[i]}\"\n      local parent=${path%/*}\n      if [ -d \"$path\" ]; then\n        if [ -w \"$path\" ]; then\n          result=\"${result:+$result:}$path\"\n        fi\n      elif [ -d \"$parent\" ]; then\n        if [ -w \"$parent\" ]; then\n          result=\"${result:+$result:}$path\"\n        fi\n      fi\n      ((i++))\n  done\n  printf \"%s\" \"$result\"\n}\n\n# Test if shell is executed or sourced\n# # if [[ \"${BASH_SOURCE[0]}\" =~ .*\"$0\"$ ]]; then\n# if [[ \"${BASH_SOURCE[0]}\" == \"$0\" ]]; then\n#     echo EXECUTED\n# else\n#     echo SOURCED\n# fi\n\n# Return true if context is executed\nshell_is_executed () {\n  [[ \"${BASH_SOURCE[0]}\" == \"$0\" ]]\n}\n\n# Return false if context is sourced\nshell_is_sourced () {\n  ! shell_is_executed\n}\n\n# Return false if context is sourced\nshell_is_known () {\n  local name=$1\n  case \"$name\" in\n    */sh) echo \"$name\" ;; \n    */ash) echo \"$name\" ;; \n    */bash) echo \"$name\" ;; \n    */zsh) echo \"$name\" ;; \n    *) return 1;; \n  esac\n}\n\n# Sources:\n# https://serverfault.com/questions/146745/how-can-i-check-in-bash-if-a-shell-is-running-in-interactive-mode\n\n# Return true if terminal stdin is interactive terminal\nshell_is_interactive () {\n  [ -t 0 ]\n}\n\n# Return true if terminal stdin is not interactive\nshell_is_not_interactive () {\n  ! [ -t 0 ]\n}\n\n\n\n# Source a shell file\nshell_source ()\n{\n  local path=$1\n  shift 1 || true\n  local rc=0\n\n  PWD=\"${path%/*}\" . \"$path\" $@ || \\\n    {\n      rc=$?\n      &gt;&amp;2 printf \"Failed to load lib returned $rc: %s\\n\" \"$p\"\n    }\n  return $rc\n}\n\n\n# Download an &lt;URL&gt; into &lt;PATH&gt; or stdout\n# Usage:\n#  download_file &lt;URL&gt;\n#  download_file &lt;URL&gt; &lt;PATH&gt;\ndownload_file() {\n  local url=$1\n  local filename=${2:--}\n\n  if [ -z \"$url\" ]; then\n      echo \"Usage: download_file &lt;URL&gt; [&lt;FILENAME&gt;]\"\n      return 1\n  fi\n\n  # Create destination dir\n  if [ \"$filename\" != '-' ]; then\n    local parent=\"${filename%/*}\"\n    [[ -d \"${parent}\" ]] || mkdir -p \"${parent}\"\n  fi\n\n  # Find download tool\n  local rc=0\n  if command -v curl &gt; /dev/null; then\n      curl -L -s -o \"$filename\" \"$url\" || rc=$?\n      if [[ $rc -ne 0 ]]; then\n        log WARN \"Failure after curl: $rc\"\n        return 1\n      fi\n  elif command -v wget &gt; /dev/null; then\n      wget -O \"$filename\" \"$url\"\n  else\n      printf \"%s\\n\" \"Neither curl nor wget is installed. Please install one of them to use this function.\"\n      return 1\n  fi\n\n  # Report\n  if [ $? -ne 0 ]; then\n    &gt;&amp;2 printf \"ERROR: Failed to download the file: %s\\n\" \"$url\"\n    return 1\n  else\n    log TRACE \"File downloaded successfully as: $filename\"\n  fi\n}\n\n\n\n\n\n\n\n# SHXT_LOG_LEVEL=${SHXT_LOG_LEVEL:-INFO}  # DRY, DEBUG, TRACE\n# SHXT_LOG_SCALE=\"TRACE:DEBUG:RUN:INFO:DRY:HINT:NOTICE:CMD:USER:WARN:ERR:ERROR:CRIT:TODO:DIE:QUIT:PROMPT\"\n\n\n# CLI libraries\n# =================\n# Validate log level pass aginst limit\n_log_validate_level ()\n{\n  local SHXT_LOG_SCALE=\"${SHXT_LOG_SCALE:-TRACE:DEBUG:INFO:NOTICE:WARN:ERR:ERROR:CRIT:TODO:DIE:QUIT:PROMPT}\"\n\n  local level=$1\n  local limit_level=${2:-${SHXT_LOG_SCALE%%:*}}\n\n  if [[ ! \":${SHXT_LOG_SCALE#*$limit_level:}:$limit_level:\" =~ :\"$level\": ]]; then\n    if [[ ! \":${SHXT_LOG_SCALE}\" =~ :\"$level\": ]]; then\n      &gt;&amp;2 printf \"%s\\n\" \"  BUG: Unknown log level: $level\"\n    fi\n    return 1\n  fi\n}\n\n# Logging support, with levels\nlog () \n{\n  local SHXT_LOG_LEVEL=${SHXT_LOG_LEVEL:-INFO}\n\n  local old_setting=${-//[^x]/}; set +x\n  local level=\"${1:-DEBUG}\"\n  shift 1 || true\n\n  # Check log level filter\n  if _log_validate_level \"$level\" \"$SHXT_LOG_LEVEL\"; then\n\n    local msg=${*}\n    if [[ \"$msg\" == '-' ]]; then\n      msg=\"$(cat -)\"\n    fi\n    while read -r -u 3 line; do\n      &gt;&amp;2 printf \"%6s: %s\\\\n\" \"$level\" \"${line:- }\"\n    done 3&lt;&lt;&lt;\"$msg\"\n  fi\n\n  # Restore trace mode if was enabled\n  if [[ -n \"${old_setting-}\" ]]; then set -x; else set +x; fi\n}\n\n# Terminate all with error message and rc code\nlog_die ()\n{\n    local rc=${1:-1}\n    shift 1 || true\n    local msg=\"${*:-}\"\n    local prefix=DIE\n    [[ \"$rc\" -eq 0 ]] || prefix=DIE\n    if [[ -z \"$msg\" ]]; then\n      [ \"$rc\" -ne 0 ] || exit 0\n      log \"$prefix\" \"Program terminated with error: $rc\"\n    else\n      log \"$prefix\" \"$msg\"\n    fi\n\n    # Remove EXIT trap and exit nicely\n    trap '' EXIT\n    exit \"$rc\"\n}\n\n\n\n\n\n\n\n# =============================================================\n# Internal libraries: Registries\n# =============================================================\n\n\n# Register library\n# Usage: loader_register STORE PATH [NAME]\nloader_register()\n{\n  local store_name=$1\n  local store=${!store_name}\n  local path=$2\n  local file=${3:-${path##*/}}\n  local dir=${path%/*}\n\n  # # Do initial load\n  # if [[ -z \"${SHLIB-}\" ]]; then\n  #   SHSRC=$path\n  #   SHSRC_FILE=$file\n  #   SHSRC_DIR=$dir\n  # fi\n\n  # Check if lib is not already registered\n  # [[ \":${store-}:\" != *:$file:* ]] || {\n  [[ \":${store-}:\" != *:$file=*:* ]] || {\n    &gt;&amp;2 printf \"Item already registered: %s\\n\" \"$file\"\n    return 1\n  }\n\n  # Add module into SHLIB\n  declare -g \"$store_name\"=\"${store:+$store:}$file=$path\"\n\n  # Importing vars\n  _IMPORT_PATH=$path\n  _IMPORT_FILE=$file\n  _IMPORT_DIR=$dir\n}\n\n\n\n\n\n\n# =============================================================\n# Init Loader\n# =============================================================\n\n\n# Prepare import.sh environment\nshxt_init()\n{\n\n  local auto_install=true\n  local auto_update=true\n  local debug=false\n  local trace=false\n  local OPTIND=0\n  while getopts 'dxuUlL' opt; do\n    case ${opt} in\n      d)\n        debug=true\n        ;;\n      x)\n        trace=true\n        ;;\n      u)\n        auto_update=true\n        ;;\n      U)\n        auto_update=false\n        ;;\n      l)\n        auto_install=true\n        ;;\n      L)\n        auto_install=false\n        ;;\n      ?)\n        log ERROR \"Invalid option: -${OPTARG}.\"\n        return 1\n        ;;\n    esac\n    OPTIND=$((OPTIND + 1))\n  done\n  OPTIND=$((OPTIND - 1))\n  shift \"$OPTIND\"\n\n\n  # Enable flags\n  if [[ \"$debug\" == true ]]; then\n    SHXT_LOG_LEVEL=TRACE\n    log INFO \"shxt.sh debug mode enabled\"\n  fi\n  if [[ \"$trace\" == true ]]; then\n    set -x\n  fi\n\n  # Init core\n  local d=${1-} # ${1:-$(ps -o args= $$)}\n\n  local path=$(realpath \"$0\")\n  local root=\"${path%/*}${d:+/$d}\"\n\n\n  # Autodetect current installation\n\n  local install_path=$(command -v \"shxt.sh\" 2&gt;/dev/null)\n  local need_update=false\n  if [[ \"$auto_install\" == true ]] &amp;&amp; [[ ! -x \"$install_path\" ]] ; then\n    # Auto install in PATH if not installed\n    log INFO \"Auto-installing shxt.sh\"\n    if _loader2__install; then\n      need_update=true\n    fi\n\n  elif [[ \"$auto_update\" == true ]] &amp;&amp; [[ -x \"$install_path\" ]] ; then\n    # Run auto update ...\n    local max_days=7\n    local max_age_ts=$(date -d \"now - $max_days days\" +%s)\n    local last_update_ts=$(date -r \"$install_path\" +%s)\n    if (( last_update_ts &lt;= max_age_ts )); then\n      # echo \"$filename is older than 100 days\"\n      log INFO \"Auto-updating shxt.sh because older than $max_days days\"\n      if _loader2__install; then\n        need_update=true\n      fi\n    else\n      log TRACE \"No need to update, newer than $max_days days\"\n    fi\n  fi\n\n  # Reload code\n  if [[ \"$need_update\" == true ]]; then\n    log TRACE \"Reloading shxt source code\"\n    install_path=$(command -v \"shxt.sh\" 2&gt;/dev/null)\n    . \"$install_path\"\n  fi\n  export SHXT_INSTALL_PATH=$install_path\n\n\n\n  # set +x\n\n  # Auto-register into SHLIB or quit\n  export SHXT_LIBS=''\n  loader_register SHXT_LIBS \"$path\" shxt.sh || return 0\n  export SHXT_VERSION=0.0.1\n  export USER=${USER:-$(id -u)}\n  export SHXT_NEEDLE=${SHXT_NEEDLE:-${USER}-$(cksum &lt;&lt;&lt; \"$path\" | cut -f 1 -d ' ')}\n\n  # Find most suitable RW path\n  export SHXT_DATA_DIRS=$(varpath_find_rw_dir \\\n    \"$HOME/.local/share/shxt\" \\\n    \"$HOME/.tmp/shxt\" \\\n    \"/tmp/\" \\\n    \"/dev/shm/\" \\\n    \"$root/cache/\" \\\n    \"$root/tmp/\"\n    )\n\n  # Keep only first writable dir and append program needle\n  export SHXT_RW_PATH=\"${SHXT_DATA_DIRS%%:*}${SHXT_DATA_DIRS:+/$SHXT_NEEDLE}\"\n\n  # Etra dirs\n  export SHXT_DIR_BIN=${SHXT_RW_PATH:+$SHXT_RW_PATH/bin}\n  export SHXT_DIR_LIB=${SHXT_RW_PATH:+$SHXT_RW_PATH/lib}\n  export SHXT_DIR_FILES=${SHXT_RW_PATH:+$SHXT_RW_PATH/files}\n\n  [ -d \"${SHXT_DIR_BIN:-}\" ] || mkdir -p \"${SHXT_DIR_BIN}\"\n  [ -d \"${SHXT_DIR_LIB:-}\" ] || mkdir -p \"${SHXT_DIR_LIB}\"\n  [ -d \"${SHXT_DIR_FILES:-}\" ] || mkdir -p \"${SHXT_DIR_FILES}\"\n\n\n  # return 1\n\n  # # Prepare lookup paths\n\n  export SHXT_LIB_PATHS=\n  # varpath_append SHXT_LIB_PATHS \"$root/lib\"\n  # varpath_append SHXT_LIB_PATHS \"$root/libexec\"\n  # varpath_append SHXT_LIB_PATHS \"$root\"\n  # varpath_append SHXT_LIB_PATHS \"$SHXT_DIR_SHARED/lib\"\n  # varpath_append SHXT_LIB_PATHS \"$SHXT_DIR_DOWNLOADS/$SHXT_NEEDLE/lib\"\n\n  # export SHXT_FILE_PATHS=\n  # varpath_append SHXT_FILE_PATHS \"$root/share\"\n  # varpath_append SHXT_FILE_PATHS \"$root\"\n  # varpath_append SHXT_FILE_PATHS \"$SHXT_DIR_SHARED/share\"\n  # varpath_append SHXT_FILE_PATHS \"$SHXT_DIR_DOWNLOADS/$SHXT_NEEDLE/files\"\n\n  export SHXT_BIN_PATHS=$PATH\n  # varpath_prepend SHXT_BIN_PATHS \"/usr/local/sbin/\"\n  # varpath_prepend SHXT_BIN_PATHS \"/usr/local/bin/\"\n  # varpath_prepend SHXT_BIN_PATHS \"$HOME/bin\"\n  # varpath_prepend_force SHXT_BIN_PATHS \"$HOME/.local/bin\"\n  # varpath_prepend_force SHXT_BIN_PATHS \"$HOME/.local/scripts\"\n\n  varpath_prepend SHXT_BIN_PATHS \"$root/bin\"\n  varpath_prepend SHXT_BIN_PATHS \"$root\"\n  varpath_prepend SHXT_BIN_PATHS \"$SHXT_DIR_BIN\"\n  varpath_prepend SHXT_BIN_PATHS \"$SHXT_DIR_SHARED/bin\"\n  # varpath_prepend SHXT_BIN_PATHS \"$SHXT_DIR_DOWNLOADS/$SHXT_NEEDLE/bin\"\n\n  varpath_prepend SHXT_BIN_PATHS \"$SHXT_RW_PATH\"\n\n  # log WARN \"PATH DIRS: $SHXT_BIN_PATHS\"\n\n  # Self register and init\n  # export SHXT_BIN_PATHS_OLD=${SHXT_BIN_PATHS_OLD:-$PATH}\n  # export SHXT_FILE_MAP=\n  # export SHLIB=\n  # export SHXT_LIBS='toto:titi'\n\n  # echo \"RET=$(shell_is_known $path)\"\n  # return 1\n  # loader_register SHXT_LIBS \"$path\" \n\n  # export PATH=$SHXT_BIN_PATHS\n\n\n  log TRACE \"shxt.sh inited: $SHXT_RW_PATH\"\n\n}\n\n\n# Ensure shxt.sh is installed gloabally\n_loader2__install ()\n{\n\n  local dest=${1:-}\n  # local url=\"https://mrjk.github.io/shxt/shxt.sh\"\n  # local url=\"https://mrjk.github.io/shxt/v.1/shxt.sh\"\n  local url=\"https://raw.githubusercontent.com/mrjk/shxt/refs/heads/main/shxt.sh\"\n\n  local force=false\n  while getopts ':f' opt; do\n    case ${opt} in\n      f)\n        force=true\n        ;;\n      ?)\n        log ERROR \"Invalid option: -${OPTARG}.\"\n        return 1\n        ;;\n    esac\n  done\n\n  # Quit if already installed\n  local existing=$(command -v \"shxt.sh\" 2&gt;/dev/null)\n  if [[ -x \"$existing\" ]] ; then\n    if [[ \"$force\" != true ]]; then\n      log TRACE \"shxt.sh already installed in $existing\"\n      return 0\n    fi\n  fi\n\n  # Detect install path\n  local result=\n  if [ -n \"$dest\" ]; then\n    dest=$(varpath_find_rw_dir \"$dest\")\n  else\n\n    dest=$(tr ':' '\\n' &lt;&lt;&lt; \"$PATH\" | tac | varpath_find_rw_dir -)\n    dest=${dest%%:*}\n  fi\n\n  # Ensure destination dir exists\n  [ -d \"$dest\" ] || mkdir -p \"$dest\"\n  if [ ! -w \"$dest\" ] ; then\n    log ERROR \"Impossible to install or write in path: $dest\"\n    return 1\n  fi\n\n  # Ensure a file has been updated\n  local _shxt_ctx_target_download_path=\"$dest/shxt.sh\"\n  log INFO \"Downloading $_shxt_ctx_target_download_path from $url ...\"\n  if download_file \"$url\" \"$_shxt_ctx_target_download_path\"; then\n    chmod +x \"$_shxt_ctx_target_download_path\"\n\n    log INFO \"shxt.sh installed in $dest\"\n  else\n    log ERROR \"Failed to install shxt.sh\"\n    return 1\n  fi\n}\n\n\n\n_loader2__init ()\n{\n  echo \"Init or reconfigure shxt $@\"\n}\n\n_loader2__clean ()\n{\n  echo \"Clean shxt $@\"\n}\n\n\n\n# =============================================================\n# NEW API V2 helpers\n# =============================================================\n\n_loader2__ctx_clean () {\n  unset ${!_shxt_ctx_*}\n}\n\n_loader2__ctx_init () {\n\n  export _shxt_ctx_kind=$1\n  export _shxt_ctx_target=$2\n  export _shxt_ctx_target_installed=false\n  export _shxt_ctx_target_downloaded=false\n\n  export _shxt_ctx_store_name=\n  export _shxt_ctx_store_paths=\n\n  export _shxt_ctx_target_download_dir=\n  export _shxt_ctx_target_download_path=\n  export _shxt_ctx_target_dir=\n  export _shxt_ctx_target_path=\n\n  # source_url=${3:-}\n\n  case \"$_shxt_ctx_kind\" in\n    bin)\n      _shxt_ctx_store_name=SHXT_BIN_PATHS\n      _shxt_ctx_target_download_dir=${SHXT_RW_PATH:+$SHXT_RW_PATH/bin}\n      # path_suffix=\"$SHXT_DIR_BIN\"\n      ;;\n    lib)\n      _shxt_ctx_store_name=SHXT_LIB_PATHS\n      _shxt_ctx_target_download_dir=${SHXT_RW_PATH:+$SHXT_RW_PATH/lib}\n      # path_suffix=\"$SHXT_DIR_LIB\"\n      ;;\n    file)\n      _shxt_ctx_store_name=SHXT_FILE_PATHS\n      _shxt_ctx_target_download_dir=${SHXT_RW_PATH:+$SHXT_RW_PATH/files}\n      # path_suffix=\"$SHXT_DIR_FILES\" \n      ;;  \n    *) \n      &gt;&amp;2 printf \"_loader2__ctx_init does not support kind '%s', please use one of: %s\\n\" \"$_shxt_ctx_kind\" \"bin, lib or file\"\n      return 8\n    ;;\n  esac\n\n  # Ensure path is always up to date\n  export PATH=$SHXT_BIN_PATHS\n\n  # Set custom paths\n  _shxt_ctx_store_paths=${!_shxt_ctx_store_name}\n  _shxt_ctx_target_download_path=${_shxt_ctx_target_download_dir:+$_shxt_ctx_target_download_dir/$_shxt_ctx_target}\n\n  # Lookup if not downloaded\n  if [ -f \"$_shxt_ctx_target_download_path\" ]; then\n    _shxt_ctx_target_path=\"$_shxt_ctx_target_download_path\"\n    _shxt_ctx_target_downloaded=true\n  else\n    _shxt_ctx_target_path=$(varpath_find2 \"$_shxt_ctx_store_name\" \"$_shxt_ctx_target\" || true)\n  fi\n\n  # Report if installed\n  _shxt_ctx_target_dir=${_shxt_ctx_target_path%/*}\n  if [ -f \"$_shxt_ctx_target_path\" ]; then\n    _shxt_ctx_target_installed=true\n  fi\n\n}\n\n# ======================\n# NEW API V2 LOADER\n# ======================\n\n\n_loader2__download ()\n{\n  _loader2__ctx_init \"$@\"\n  shift 2\n  local url=${1:-}\n\n  # Ensure URL is available\n  if [ -z \"$url\" ]; then\n    log CRIT \"Missing URL for $_shxt_ctx_target !\"\n    return 1\n  fi\n\n  if [ \"$_shxt_ctx_target_downloaded\" != true ]; then\n    # log INFO \"Downloading $_shxt_ctx_target ...\"\n    _loader2__update \"$_shxt_ctx_kind\" \"$_shxt_ctx_target\" \"$url\"\n  # else\n  #   log INFO \"Using downloaded $_shxt_ctx_target ...\"\n  fi\n\n}\n\n_loader2__update ()\n{\n  _loader2__ctx_init \"$@\"\n  shift 2\n  local url=${1:-}\n\n  # Ensure URL is available\n  if [ -z \"$url\" ]; then\n    log CRIT \"Missing URL for $_shxt_ctx_target !\"\n    return 1\n  fi\n\n  # Ensure a file has been updated\n  log INFO \"Downloading $_shxt_ctx_target from $url ...\"\n  download_file \"$url\" \"$_shxt_ctx_target_download_path\"\n  if [ \"$_shxt_ctx_kind\" == bin ]; then\n    chmod +x \"$_shxt_ctx_target_download_path\"\n  fi\n}\n\n_loader2__use ()\n{\n  _loader2__ctx_init \"$@\"\n  shift 2\n  local url=${1:-}\n\n  if [ \"$_shxt_ctx_target_installed\" != true ]; then\n    _loader2__update \"$_shxt_ctx_kind\" \"$_shxt_ctx_target\" \"$url\"\n  fi\n\n  # Enable the thing ...\n  case \"$_shxt_ctx_kind\" in\n    lib)\n      local old_cd=$PWD\n      log INFO \"Sourcing lib $_shxt_ctx_target_path\"\n      cd \"${_shxt_ctx_target_dir}\"\n      . \"${_shxt_ctx_target_path}\"\n      cd \"${old_cd}\"\n      ;;\n    file) ;;  \n  esac\n\n}\n\n_loader2__path ()\n{\n  _loader2__ctx_init \"$@\"\n  printf '\\s' \"$_shxt_ctx_target_path\"\n}\n\n_loader2__cat ()\n{\n  _loader2__ctx_init \"$@\"\n  if [ -f \"$_shxt_ctx_target_path\" ]; then\n    cat \"$_shxt_ctx_target_path\"\n  fi\n  return 1\n}\n\n\n_loader2__help_cli ()\n{\n  cat &lt;&lt;EOF\nMode: Executed\nUsage: $0 --help\n  $0 version\n  $0 help\n  $0 install [PATH]         Install/update automatically in PATH\n\n\nInfos:\n  SHXT_INSTALL_PATH=$SHXT_INSTALL_PATH\nEOF\n\n}\n\n_loader2__help_api ()\n{\n  cat &lt;&lt;EOF\nMode: Sourced\nUsage: . $0\n  $0 version\n  $0 help\n  $0 install [PATH]         Install/update automatically in PATH\n\n  $0 use [bin|lib|file] [NAME] [PATH]         Use an item, locally or remotely\n  $0 download [bin|lib|file] [NAME] [PATH]    Download an item\n  $0 update [bin|lib|file] [NAME] [PATH]      Always update an item\n\nInfos:\n  SHXT_INSTALL_PATH=$SHXT_INSTALL_PATH\n\nEOF\n\n}\n\n\nloader_cli ()\n{\n  local action=$1\n  case \"$action\" in\n    help|--help|-h)\n      _loader2__help_cli\n      return $?\n    ;;\n  esac\n\n  loader \"$@\"\n\n}\n\n\n# Main API\nloader ()\n{\n  local action=$1\n  shift 1\n\n  case \"$action\" in\n    version)\n      printf '%s\\n' \"1.0.0\"\n      return $?\n    ;;\n    install)\n      _loader2__install \"$@\"\n      return $?\n    ;;\n    init|conf)\n      _loader2__init \"$@\"\n      return $?\n    ;;\n    app|start|clean)\n      _loader2__clean \"$@\"\n      return $?\n    ;;\n  esac\n\n\n  case \"$action\" in\n    # Behavioral settings\n    download|install)\n      _loader2__download \"$@\"\n    ;;\n    update)\n      _loader2__update \"$@\"\n    ;;\n    use|source|enable)\n      _loader2__use \"$@\"\n    ;;\n\n    # Informative API\n    path)\n      _loader2__path \"$@\"\n    ;;\n    cat)\n      _loader2__cat \"$@\"\n    ;;\n\n    *) \n      &gt;&amp;2 printf \"loader_use does not support action '%s', please use one of: %s\\n\" \"$action\" \"bin, lib or file\"\n      return 8\n    ;;\n  esac\n\n  _loader2__ctx_clean\n\n}\n\nloader2 () \n{\n  loader \"$@\"\n}\n\n\n# =============================================================\n# Internal libraries\n# =============================================================\n\n\n# # =============================================================\n# # Script loader\n# # =============================================================\n\n# # if [[ \"${BASH_SOURCE[0]}\" =~ .*\"$0\"$ ]]; then\n# if [[ \"${BASH_SOURCE[0]}\" == \"$0\" ]]; then\n\n#   &gt;&amp;2 printf \"$0 is not meant to be called, but sourced in shell scripts. See help usage below:\\n\\n\"\n#   import__help\n#   exit 1\n\n# else\n#   shxt_init \"$@\"\n# fi\n\n\n# Use cases:\n#  eval \"$(cat ../shxt.sh)\"\n\n\n# if [[ \"${BASH_SOURCE[0]}\" =~ .*\"$0\"$ ]]; then\nif [[ \"${BASH_SOURCE[0]}\" == \"$0\" ]]; then\n\n  # shxt_init\n  shxt_init\n  loader_cli \"$@\"\n\nelse\n  shxt_init \"$@\"\n\nfi\n</code></pre>"}]}